{"version":3,"file":"ts-tokenizr.js","sources":["../src/Token.ts","../src/ActionContext.ts","../src/lib/excerpt.ts","../src/lib/ParsingError.ts","../src/lib/MatchResult.ts","../src/lib/guards.ts","../src/lib/StateStack.ts","../src/lib/Stack.ts","../src/State.ts","../src/lib/arrayEquals.ts","../src/Rule.ts","../src/Tokenizr.ts"],"sourcesContent":["export class Token {\n  type: string;\n  value: unknown;\n  text: string;\n  pos: number;\n  line: number;\n  column: number;\n\n  constructor(\n    type: string,\n    value: unknown,\n    text: string,\n    pos = 0,\n    line = 0,\n    column = 0\n  ) {\n    this.type = type;\n    this.value = value;\n    this.text = text;\n    this.pos = pos;\n    this.line = line;\n    this.column = column;\n  }\n\n  toString(): string {\n    const tokenAttr = [\n      `type: ${this.type}`,\n      `value: ${JSON.stringify(this.value)}`,\n      `text: ${JSON.stringify(this.text)}`,\n      `pos: ${this.pos}`,\n      `line: ${this.line}`,\n      `column: ${this.column}`\n    ].join(\", \");\n\n    return `<${tokenAttr}>`;\n  }\n\n  isA(type: string, value?: unknown): boolean {\n    if (type !== this.type) {\n      return false;\n    }\n\n    if (value && value !== this.value) {\n      return false;\n    }\n\n    return true;\n  }\n}\n","import { Token } from \"./Token\";\nimport { Tokenizr } from \"./Tokenizr\";\n\nexport class ActionContext {\n  _tokenizr: Tokenizr;\n  _repeat = false;\n  _reject = false;\n  _ignore = false;\n  _data: Record<string, unknown> = {};\n  _match: RegExpExecArray | null = null;\n\n  constructor(tokenizr: Tokenizr) {\n    this._tokenizr = tokenizr;\n  }\n\n  /**\n   * Store and retrieve user data attached to context\n   */\n  data(key: string): unknown;\n  data(key: string, value: unknown): void;\n  data(key: string, value?: unknown): unknown | true {\n    if (typeof value === \"undefined\") {\n      return this._data[key];\n    }\n\n    this._data[key] = value;\n\n    return true;\n  }\n\n  /**\n   * Retrieve information of current matching\n   */\n  info(): {\n    line: number;\n    column: number;\n    pos: number;\n    len: number;\n  } {\n    const len = this._match ? this._match[0].length : NaN;\n\n    return {\n      line: this._tokenizr._line,\n      column: this._tokenizr._column,\n      pos: this._tokenizr._pos,\n      len\n    };\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  push(state: string): this {\n    this._tokenizr.push(state);\n\n    return this;\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  pop(): this {\n    this._tokenizr.pop();\n\n    return this;\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  state(): string;\n  state(state: string): this;\n  state(state?: string): this | string {\n    if (typeof state === \"undefined\") {\n      return this._tokenizr.state();\n    }\n\n    this._tokenizr.state(state);\n\n    return this;\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  tag(tag: string): this {\n    this._tokenizr.tag(tag);\n\n    return this;\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  tagged(tag: string): boolean {\n    return this._tokenizr.tagged(tag);\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  untag(tag: string): this {\n    this._tokenizr.untag(tag);\n\n    return this;\n  }\n\n  /**\n   * Mark current matching to be repeated from scratch\n   */\n  repeat(): this {\n    this._tokenizr._log(\"    REPEAT\");\n    this._repeat = true;\n\n    return this;\n  }\n\n  /**\n   * Mark current matching to be rejected\n   */\n  reject(): this {\n    this._tokenizr._log(\"    REJECT\");\n    this._reject = true;\n\n    return this;\n  }\n\n  /**\n   * Mark current matching to be ignored\n   */\n  ignore(): this {\n    this._tokenizr._log(\"    IGNORE\");\n    this._ignore = true;\n\n    return this;\n  }\n\n  /**\n   * Accept current matching as a new token\n   */\n  accept(type: string): this;\n  accept(type: string, value: unknown): this;\n  accept(type: string, value?: unknown): this {\n    if (this._match === null) {\n      throw Error(\"this._match was null when trying to .accept()\");\n    }\n\n    if (typeof value === \"undefined\") {\n      // eslint-disable-next-line no-param-reassign\n      value = this._match[0];\n    }\n\n    this._tokenizr._log(\n      `    ACCEPT: type: ${type}, value: ` +\n        `${JSON.stringify(value)} (${typeof value}), text: \"${\n          this._match[0]\n        }\"`\n    );\n\n    this._tokenizr._pending.push(\n      new Token(\n        type,\n        value,\n        this._match[0],\n        this._tokenizr._pos,\n        this._tokenizr._line,\n        this._tokenizr._column\n      )\n    );\n\n    return this;\n  }\n\n  /**\n   * Immediately stop tokenization\n   */\n  stop(): this {\n    this._tokenizr._stopped = true;\n\n    return this;\n  }\n}\n","/* eslint-disable no-control-regex */\nimport { Excerpt } from \"../types\";\n\nfunction hex(ch: string): string {\n  return ch.charCodeAt(0).toString(16).toUpperCase();\n}\n\nfunction extract(txt: string, pos: number, len: number): string {\n  return txt\n    .substr(pos, len)\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\\x08/g, \"\\\\b\")\n    .replace(/\\t/g, \"\\\\t\")\n    .replace(/\\n/g, \"\\\\n\")\n    .replace(/\\f/g, \"\\\\f\")\n    .replace(/\\r/g, \"\\\\r\")\n    .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, ch => \"\\\\x0\" + hex(ch))\n    .replace(/[\\x10-\\x1F\\x80-\\xFF]/g, ch => \"\\\\x\" + hex(ch))\n    .replace(/[\\u0100-\\u0FFF]/g, ch => \"\\\\u0\" + hex(ch))\n    .replace(/[\\u1000-\\uFFFF]/g, ch => \"\\\\u\" + hex(ch));\n}\n\n/**\n * Create a source excerpt\n */\nexport function excerpt(txt: string, offset: number): Excerpt {\n  const textLength = txt.length;\n\n  let start = offset - 20;\n  if (start < 0) start = 0;\n\n  let end = offset + 20;\n  if (end > textLength) end = textLength;\n\n  return {\n    prologTrunc: start > 0,\n    prologText: extract(txt, start, offset - start),\n    tokenText: extract(txt, offset, 1),\n    epilogText: extract(txt, offset + 1, end - (offset + 1)),\n    epilogTrunc: end < textLength\n  };\n}\n","import { excerpt } from \"./excerpt\";\n\nexport class ParsingError extends Error {\n  pos: number;\n  line: number;\n  column: number;\n  input: string;\n\n  constructor(\n    message: string,\n    pos: number,\n    line: number,\n    column: number,\n    input: string\n  ) {\n    super(message);\n\n    this.name = \"ParsingError\";\n    this.message = message;\n    this.pos = pos;\n    this.line = line;\n    this.column = column;\n    this.input = input;\n  }\n\n  /**\n   * Render a useful string representation\n   */\n  toString(): string {\n    const l = excerpt(this.input, this.pos);\n    const prefix1 = `line ${this.line} (column ${this.column}): `;\n\n    let prefix2 = \"\";\n\n    for (let i = 0; i < prefix1.length + l.prologText.length; i++)\n      prefix2 += \" \";\n\n    const msg =\n      \"Parsing Error: \" +\n      this.message +\n      \"\\n\" +\n      prefix1 +\n      l.prologText +\n      l.tokenText +\n      l.epilogText +\n      \"\\n\" +\n      prefix2 +\n      \"^\";\n\n    return msg;\n  }\n}\n","export class MatchResult {\n  matched = false;\n\n  input?: string;\n  index?: number;\n  result: string[] = [];\n\n  length: number;\n  map: string[][\"map\"];\n  find: string[][\"find\"];\n  filter: string[][\"filter\"];\n  includes: string[][\"includes\"];\n\n  constructor(execArray: RegExpExecArray | null) {\n    if ((this.matched = execArray !== null)) {\n      this.input = execArray.input;\n      this.index = execArray.index;\n\n      Object.entries(execArray).forEach(([key, value]) => {\n        if (key !== \"groups\" && key !== \"input\" && key !== \"index\") {\n          this.result.push(value);\n        }\n      });\n    }\n\n    this.map = this.result.map;\n    this.find = this.result.find;\n    this.filter = this.result.filter;\n    this.length = this.result.length;\n    this.includes = this.result.includes;\n  }\n}\n","import { AssertionError } from \"assert\";\n\nexport function isRegExp(o: unknown): o is RegExp {\n  return typeof (o as RegExp).compile !== \"undefined\";\n}\n\nexport function assertIsString(\n  input: unknown,\n  error?: string\n): asserts input is string {\n  if (typeof input !== \"string\") {\n    throw new AssertionError({\n      expected: \"string\",\n      actual: typeof input,\n      message: error || \"The given input must be a string.\"\n    });\n  }\n}\n","import { Stack } from \"./Stack\";\n\nexport class StateStack extends Stack<string> {\n  constructor(private defaultState: string) {\n    super();\n    this.defaultState = defaultState;\n    this.elements.push(this.defaultState);\n  }\n\n  get isEmpty(): boolean {\n    return this.elements.length === 1;\n  }\n\n  clear(): void {\n    this.elements = [this.defaultState];\n  }\n\n  pop(): string {\n    if (this.isEmpty) {\n      throw Error(\n        `ERROR: Cannot pop the default state \"${this.defaultState}\"`\n      );\n    }\n\n    return this.elements.pop() as string;\n  }\n\n  peek(): string {\n    return this.elements[this.elements.length - 1];\n  }\n}\n","export class Stack<T> {\n  static init<T>(element: T): Stack<T> {\n    const stack = new Stack<T>();\n\n    stack.push(element);\n\n    return stack;\n  }\n\n  protected elements: T[] = [];\n\n  get length(): number {\n    return this.elements.length;\n  }\n\n  get isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  get isNotEmpty(): boolean {\n    return !this.isEmpty;\n  }\n\n  clear(): void {\n    this.elements = [];\n  }\n\n  push(element: T): number {\n    return this.elements.push(element);\n  }\n\n  pop(): T | undefined {\n    return this.elements.pop();\n  }\n\n  peek(): T | undefined {\n    return this.isNotEmpty ? this.elements[this.length - 1] : undefined;\n  }\n}\n","import { arrayEquals } from \"./lib\";\n\nexport class State {\n  static default(): State {\n    return new State(\"default\");\n  }\n\n  static create(taggedState: string): State {\n    return new State(taggedState);\n  }\n\n  name = \"default\";\n  tags: string[] = [];\n\n  get isTagged(): boolean {\n    return this.tags.length > 0;\n  }\n\n  constructor(stateDef: string) {\n    const pieces = stateDef.split(/\\s+/g);\n    const states = pieces.filter(p => !p.startsWith(\"#\"));\n\n    if (states.length !== 1) {\n      throw new Error(\"exactly one state required\");\n    }\n\n    this.name = states[0];\n    this.tags = pieces\n      .filter(piece => piece.startsWith(\"#\"))\n      .map(tag => tag.replace(\"#\", \"\"));\n  }\n\n  toString(): string {\n    return `${this.name} ${this.stringifyTags()}`;\n  }\n\n  stringifyTags(): string {\n    return this.tags.map(tag => `#${tag}`).join(\" \");\n  }\n\n  /**\n   * Test if this state's name mathces the provided name\n   */\n  is(state: string): boolean {\n    return this.name === state;\n  }\n\n  /**\n   * Test if two State objects match\n   */\n  matches(state: State): boolean {\n    return (\n      this.name === state.name && arrayEquals(this.tags, state.tags)\n    );\n  }\n\n  filterTags(cb: (tag: string) => boolean): string[] {\n    return this.tags.filter(cb);\n  }\n\n  hasTag(tag: string): boolean {\n    return this.tags.includes(tag);\n  }\n\n  tag(tag: string): this {\n    this.tags.push(tag);\n\n    return this;\n  }\n\n  unTag(tag: string): this {\n    delete this.tags[this.tags.indexOf(tag)];\n\n    return this;\n  }\n}\n\nexport function statesMatch(\n  state1: string | State,\n  state2: string | State\n): boolean {\n  if (state1 instanceof State) {\n    // eslint-disable-next-line no-param-reassign\n    state1 = state1.name;\n  }\n\n  if (state2 instanceof State) {\n    // eslint-disable-next-line no-param-reassign\n    state2 = state2.name;\n  }\n\n  return state1 === state2;\n}\n","export function arrayEquals(a1: unknown[], a2: unknown[]): boolean {\n  if (a1 === a2) {\n    return true;\n  }\n\n  if (a1.length !== a2.length) {\n    return false;\n  }\n\n  return a1\n    .map(item => a2.includes(item))\n    .reduce((a, c) => a && c, true);\n}\n","import { assertIsString } from \"./lib/guards\";\nimport { MatchResult } from \"./lib/MatchResult\";\nimport { State } from \"./State\";\nimport { Action } from \"./types\";\n\nexport class Rule {\n  _action!: Action;\n  _name = \"unknown\";\n  _pattern!: RegExp;\n  _states: State[] = [];\n  // _tags: Array<string> = [];\n\n  stringify: Record<string, CallableFunction> = {};\n\n  get states(): string[] {\n    return this._states.map(state => state.toString());\n  }\n\n  get willMatchAnyState(): boolean {\n    return this.hasState(\"*\");\n  }\n\n  get hasPattern(): boolean {\n    return typeof this._pattern !== \"undefined\";\n  }\n\n  get hasAction(): boolean {\n    return typeof this._action !== \"undefined\";\n  }\n\n  get hasName(): boolean {\n    return typeof this._name !== \"undefined\";\n  }\n\n  /**\n   * Test a string against the {@link Rule}\n   */\n  test(input: string): MatchResult {\n    return new MatchResult(this._pattern.exec(input));\n  }\n\n  state(query?: string): State | undefined {\n    assertIsString(query);\n\n    return this._states.find(state => state.name === query);\n  }\n\n  hasState(state: string): boolean {\n    return this._states.filter(s => s.is(state)).length > 0;\n  }\n\n  getState(state: string): State {\n    if (!this.hasState(state)) {\n      throw Error();\n    }\n\n    return this._states.find(s => s.is(state)) as State;\n  }\n\n  getStates(): string[] {\n    return this._states.map(item => item.name);\n  }\n\n  /**\n   * Set the name for the Rule\n   */\n  setName(name: string): this {\n    this._name = name;\n\n    return this;\n  }\n\n  /**\n   * Set the {@link Action} for the {@link Rule}\n   */\n  setAction(action: Action): this {\n    this._action = action;\n\n    return this;\n  }\n\n  /**\n   * Set the state (and tags) for the Rule\n   *\n   * @example\n   * setState(\"*\")\n   * setState(\"default\")\n   * setState(\"comment #open\")\n   * setState(\"foo #bar, baz #qux\")\n   */\n  setState(input: string): this {\n    const stateDefs = input.split(/\\s*,\\s*/g);\n\n    this._states = stateDefs.map(State.create);\n\n    return this;\n  }\n\n  /**\n   * Add another matching state (and tags) for the Rule\n   *\n   * @example\n   * setState(\"*\")\n   * setState(\"default\")\n   * setState(\"comment #open\")\n   * setState(\"custom #foo #bar #baz\")\n   */\n  addState(input: string): this {\n    this._states.push(new State(input));\n\n    return this;\n  }\n\n  setPattern(pattern: RegExp): this {\n    /* ECMAScript <= 5 */\n    let flags = \"g\";\n\n    try {\n      const regexp = new RegExp(\"\", \"y\");\n      if (typeof regexp.sticky === \"boolean\") {\n        /* ECMAScript >= 2015 */\n        flags = \"y\";\n      }\n    } catch (ex) {\n      /*  no-op  */\n    }\n\n    if (typeof pattern.multiline === \"boolean\" && pattern.multiline)\n      flags += \"m\";\n    if (typeof pattern.dotAll === \"boolean\" && pattern.dotAll)\n      flags += \"s\";\n    if (typeof pattern.ignoreCase === \"boolean\" && pattern.ignoreCase)\n      flags += \"i\";\n    if (typeof pattern.unicode === \"boolean\" && pattern.unicode)\n      flags += \"u\";\n\n    this._pattern = new RegExp(pattern.source, flags);\n\n    return this;\n  }\n}\n","import { ActionContext } from \"./ActionContext\";\nimport { assertIsString, excerpt, isRegExp } from \"./lib\";\nimport { ParsingError } from \"./lib/ParsingError\";\nimport { StateStack } from \"./lib/StateStack\";\nimport { Rule } from \"./Rule\";\nimport { Token } from \"./Token\";\nimport {\n  Action,\n  DepthError,\n  FinishAction,\n  Tags,\n  TokenizrConfig\n} from \"./types\";\n\nexport class Tokenizr {\n  static readonly defaults = {\n    debug: false\n  };\n\n  config: TokenizrConfig;\n\n  _len = 0;\n  _pos = 0;\n  _line = 1;\n  _column = 1;\n  _input = \"\";\n  _eof = false;\n  _stopped = false;\n  _ctx: ActionContext;\n  _rules: Rule[] = [];\n  _pending: Token[] = [];\n  _after: Action | null = null;\n  _before: Action | null = null;\n  _finish: FinishAction | null = null;\n  // _tags: Array<string> = [];\n  _state: StateStack;\n  _tag: Tags = {};\n  // _state: Array<string> = [\"default\"];\n  _transaction: Token[][] = [];\n\n  constructor(config?: Partial<TokenizrConfig>) {\n    this.config = { ...Tokenizr.defaults, ...config };\n\n    this._state = new StateStack(\"default\");\n\n    this._ctx = new ActionContext(this);\n  }\n\n  /**\n   * Reset the internal state\n   */\n  reset(): this {\n    this._input = \"\";\n    this._len = 0;\n    this._eof = false;\n    this._pos = 0;\n    this._line = 1;\n    this._column = 1;\n    // this._state = [\"default\"];\n    // this._tag = {};\n    this._transaction = [];\n    this._pending = [];\n    this._stopped = false;\n\n    this._state.clear();\n\n    this._ctx = new ActionContext(this);\n\n    return this;\n  }\n\n  /**\n   * Create an error message for the current position\n   */\n  error(message: string): ParsingError {\n    return new ParsingError(\n      message,\n      this._pos,\n      this._line,\n      this._column,\n      this._input\n    );\n  }\n\n  /**\n   * Configure debug operation\n   */\n  debug(debug: boolean): this {\n    this.config.debug = debug;\n\n    return this;\n  }\n\n  /**\n   * Provide (new) input string to tokenize\n   */\n  input(input: string): this {\n    assertIsString(input);\n\n    this.reset();\n\n    this._input = input;\n    this._len = input.length;\n\n    return this;\n  }\n\n  /**\n   * Push state\n   */\n  push(state: string): this {\n    const oldState = this._state.peek();\n\n    this._state.push(state);\n\n    this._log(`    STATE (PUSH): old: <${oldState}>, new: <${state}>`);\n\n    return this;\n  }\n\n  /**\n   * Pop state from the stack\n   */\n  pop(): this {\n    if (this._state.length < 2) {\n      throw new Error(\"no more custom states to pop\");\n    }\n\n    /*  pop old state  */\n    const oldState = this._state.pop();\n\n    this._log(\n      `    STATE (POP): old: <${oldState}>, new: <${this._state.peek()}>`\n    );\n\n    return this;\n  }\n\n  /**\n   * get/set the state\n   */\n  state(): string;\n  state(state: string): this;\n  state(state?: string): this | string {\n    if (typeof state === \"undefined\") {\n      return this._state.peek();\n    }\n\n    this._log(\n      \"    STATE (SET): \" +\n        `old: <${this._state.peek()}>, ` +\n        `new: <${state}>`\n    );\n\n    this._state.push(state);\n\n    return this;\n  }\n\n  /**\n   * Set a tag\n   */\n  tag(tag: string): this {\n    this._tag[tag] = true;\n    this._log(`    TAG (ADD): ${tag}`);\n    return this;\n  }\n\n  /**\n   * Check whether tag is set\n   */\n  tagged(tag: string): boolean {\n    return this._tag[tag] === true;\n  }\n\n  /**\n   * Unset a tag\n   */\n  untag(tag: string): this {\n    delete this._tag[tag];\n    this._log(`    TAG (DEL): ${tag}`);\n    return this;\n  }\n\n  /**\n   * Configure a tokenization before-rule callback\n   */\n  before(action: Action): this {\n    this._before = action;\n    return this;\n  }\n\n  /**\n   * Configure a tokenization after-rule callback\n   */\n  after(action: Action): this {\n    this._after = action;\n    return this;\n  }\n\n  /**\n   * Configure a tokenization finish callback\n   */\n  finish(action: FinishAction): this {\n    this._finish = action;\n    return this;\n  }\n\n  /**\n   * Configure a tokenization rule\n   *\n   * Configure a token matching rule which executes its action if the\n   * current tokenization state is one of the states\n   * (and all of the currently set tags) in state (by default the rule\n   * matches all states if state is not specified) and the next input\n   * characters match against the pattern. The exact syntax of state is\n   * <state>[ #<tag> #<tag> ...][, <state>[ #<tag> #<tag> ...], ...]\n   *\n   * For example, it is one or more comma-separated state matches\n   * (OR-combined) and each state match has exactly one state and zero or more space-separated tags\n   * (AND-combined).\n   *\n   * The ctx argument provides a context object for token\n   * repeating/rejecting/ignoring/accepting and the match argument is\n   * the result of the underlying RegExp#exec call.\n   */\n  rule(state: RegExp, pattern: Action): this;\n  rule(state: RegExp, pattern: Action, action: string): this;\n  rule(state: string, pattern: RegExp, action: Action): this;\n  rule(\n    state: string,\n    pattern: RegExp,\n    action: Action,\n    name: string\n  ): this;\n  rule(\n    state: string | RegExp,\n    pattern: RegExp | Action,\n    action: Action | string = \"unknown\",\n    name = \"unknown\"\n  ): this {\n    const rule = new Rule();\n\n    if (typeof state === \"string\") {\n      rule.setState(state);\n    } else {\n      rule.setState(\"default\");\n      rule.setPattern(state);\n    }\n\n    if (isRegExp(pattern)) {\n      rule.setPattern(pattern);\n    } else {\n      rule.setAction(pattern);\n    }\n\n    if (typeof action === \"string\") {\n      rule.setName(action);\n    } else {\n      rule.setAction(action);\n    }\n\n    if (typeof name === \"string\") {\n      rule.setName(name);\n    }\n\n    this._rules.push(rule);\n\n    if (this.config.debug) {\n      this._log(\n        `rule: configure rule (state: ${rule.states}, pattern: ${rule._pattern.source})`\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Sugar method for ignoring a token w/o defining an Action to ignore\n   */\n  ignoreRule(pattern: RegExp): this {\n    return this.rule(pattern, ctx => ctx.ignore());\n  }\n\n  /**\n   * Determine and return next token\n   */\n  token(): Token | null {\n    /*  if no more tokens are pending, try to determine a new one  */\n    if (this._pending.length === 0) {\n      this._tokenize();\n    }\n\n    /*  return now potentially pending token  */\n    if (this._pending.length > 0) {\n      const token = this._pending.shift();\n\n      if (token) {\n        if (this._transaction.length > 0) {\n          this._transaction[0].push(token);\n        }\n\n        this._log(`TOKEN: ${token.toString()}`);\n\n        return token;\n      }\n    }\n\n    /*  no more tokens  */\n    return null;\n  }\n\n  /**\n   * Determine and return all tokens as an Array\n   */\n  tokens(): Token[] {\n    const result: Token[] = [];\n\n    let token;\n\n    while ((token = this.token()) !== null) result.push(token);\n\n    return result;\n  }\n\n  /**\n   * Determine and generate tokens efficiently with a generator\n   */\n  *tokenGenerator(): Generator<Token> {\n    let token;\n\n    while ((token = this.token()) !== null) {\n      yield token;\n    }\n  }\n\n  /**\n   * Sugar method for setting the input and parsing for tokens in one method.\n   */\n  tokenize(contents: string): Token[] {\n    this.input(contents);\n\n    return this.tokens();\n  }\n\n  /**\n   * Peek at the next token or token at particular offset\n   */\n  peek(offset = 0): Token {\n    for (let i = 0; i < this._pending.length + offset; i++) {\n      this._tokenize();\n    }\n\n    if (offset >= this._pending.length) {\n      throw new Error(\"not enough tokens available for peek operation\");\n    }\n\n    this._log(`PEEK: ${this._pending[offset].toString()}`);\n\n    return this._pending[offset];\n  }\n\n  /**\n   * Skip one or more tokens\n   */\n  skip(len = 1): this {\n    for (let i = 0; i < this._pending.length + len; i++) {\n      this._tokenize();\n    }\n\n    if (len > this._pending.length) {\n      throw new Error(\"not enough tokens available for skip operation\");\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    while (len-- > 0) {\n      this.token();\n    }\n\n    return this;\n  }\n\n  /**\n   * Consume the current token (by expecting it to be a particular symbol)\n   */\n  consume(type: string, value?: unknown): Token {\n    for (let i = 0; i < this._pending.length + 1; i++) {\n      this._tokenize();\n    }\n\n    if (this._pending.length === 0) {\n      throw new Error(\n        \"not enough tokens available for consume operation\"\n      );\n    }\n\n    const token = this.token() as Token;\n\n    this._log(`CONSUME: ${token.toString()}`);\n\n    const raiseError = (\n      expectedValue: unknown,\n      expectedType: string\n    ): void => {\n      throw new ParsingError(\n        `expected: <type: ${type}, value: ${JSON.stringify(\n          expectedValue\n        )} (${expectedType})>, ` +\n          `found: <type: ${token.type}, value: ${JSON.stringify(\n            token.value\n          )} (${typeof token.value})>`,\n        token.pos,\n        token.line,\n        token.column,\n        this._input\n      );\n    };\n\n    if (value && !token.isA(type, value)) {\n      raiseError(value, typeof value);\n    } else if (!token.isA(type)) {\n      raiseError(\"*\", \"any\");\n    }\n\n    return token;\n  }\n\n  /**\n   * Open tokenization transaction\n   */\n  begin(): this {\n    this._log(`BEGIN: level ${this._transaction.length}`);\n\n    this._transaction.unshift([]);\n\n    return this;\n  }\n\n  /**\n   * Determine depth of still open tokenization transaction\n   */\n  depth(): number {\n    if (this._transaction.length === 0) {\n      throw new Error(\n        \"cannot determine depth -- no active transaction\"\n      );\n    }\n\n    return this._transaction[0].length;\n  }\n\n  /**\n   * Close (successfully) tokenization transaction\n   */\n  commit(): this {\n    if (this._transaction.length === 0) {\n      throw new Error(\n        \"cannot commit transaction -- no active transaction\"\n      );\n    }\n\n    this._transaction.shift();\n\n    this._log(`COMMIT: level ${this._transaction.length}`);\n\n    return this;\n  }\n\n  /**\n   * Close (unsuccessfully) tokenization transaction\n   */\n  rollback(): this {\n    if (this._transaction.length === 0) {\n      throw new Error(\n        \"cannot rollback transaction -- no active transaction\"\n      );\n    }\n\n    this._pending = this._transaction[0].concat(this._pending);\n\n    this._transaction.shift();\n\n    this._log(`ROLLBACK: level ${this._transaction.length}`);\n\n    return this;\n  }\n\n  /**\n   * Execute multiple alternative callbacks\n   */\n  alternatives(\n    ...alternatives: ((tokenizr: this) => unknown)[]\n  ): unknown {\n    let result: unknown = null;\n    let depths: DepthError[] = [];\n\n    for (let i = 0; i < alternatives.length; i++) {\n      try {\n        this.begin();\n        result = alternatives[i].call(this, this);\n        this.commit();\n        break;\n      } catch (error) {\n        depths.push({\n          error,\n          depth: this.depth()\n        });\n        this.rollback();\n        this._log(`EXCEPTION: ${error.toString()}`);\n        continue;\n      }\n    }\n\n    if (result === null && depths.length > 0) {\n      depths = depths.sort((a, b) => a.depth - b.depth);\n\n      throw depths[0].error;\n    }\n\n    return result;\n  }\n\n  /**\n   * Output a debug message\n   */\n  _log(msg: string): void {\n    if (this.config.debug) {\n      /* eslint no-console: off */\n      console.log(`tokenizr: ${msg}`);\n    }\n  }\n\n  /**\n   * Determine the next token\n   */\n  private _tokenize(): void {\n    /*  helper function for finishing parsing  */\n    const finish = (): void => {\n      if (!this._eof) {\n        if (this._finish !== null) {\n          this._finish.call(this._ctx, this._ctx);\n        }\n\n        this._eof = true;\n\n        this._pending.push(\n          new Token(\"EOF\", \"\", \"\", this._pos, this._line, this._column)\n        );\n      }\n    };\n\n    /*  tokenize only as long as we were not stopped and there is input left  */\n    if (this._stopped || this._pos >= this._len) {\n      finish();\n      return;\n    }\n\n    /*  loop...  */\n    let continued = true;\n    while (continued) {\n      continued = false;\n\n      /*  some optional debugging context  */\n      if (this.config.debug) {\n        const e = excerpt(this._input, this._pos);\n        const tags = Object.keys(this._tag)\n          .map(tag => `#${tag}`)\n          .join(\" \");\n\n        this._log(\n          `INPUT: state: <${this._state.peek()}>, tags: <${tags}>, text: ` +\n            (e.prologTrunc ? \"...\" : '\"') +\n            `${e.prologText}<${e.tokenText}>${e.epilogText}` +\n            (e.epilogTrunc ? \"...\" : '\"') +\n            `, at: <line ${this._line}, column ${this._column}>`\n        );\n      }\n\n      /*  iterate over all rules...  */\n      for (let i = 0; i < this._rules.length; i++) {\n        const $rule = this._rules[i];\n\n        if (this.config.debug) {\n          let state = $rule.states[0];\n\n          if ($rule.states.length > 1) {\n            state = $rule.states.join(\", \");\n          }\n\n          this._log(\n            `  RULE: state(s): <${state}>, pattern: ${$rule._pattern.source}`\n          );\n        }\n\n        /*  one of rule's states (and all of its tags) has to match  */\n        let matches = false;\n        let statesMatch = false;\n\n        const currentState = this._state.peek();\n        // let idx = states.indexOf(\"*\");\n\n        /** didn't match the \"any\" state */\n        if ($rule.willMatchAnyState === false) {\n          statesMatch = $rule.hasState(currentState);\n        }\n\n        /** state matched, so check tags if any */\n        if (statesMatch) {\n          matches = true;\n\n          const matchedState = $rule.getState(currentState);\n\n          if (matchedState.isTagged) {\n            const tags = matchedState.filterTags(\n              tag => !this._tag[tag]\n            );\n\n            if (tags.length > 0) {\n              matches = false;\n            }\n          }\n        }\n\n        if (!matches) continue;\n\n        /*  match pattern at the last position  */\n        $rule._pattern.lastIndex = this._pos;\n        let found = $rule._pattern.exec(this._input);\n        $rule._pattern.lastIndex = this._pos;\n\n        if (\n          (found = $rule._pattern.exec(this._input)) !== null &&\n          found.index === this._pos\n        ) {\n          if (this.config.debug) {\n            this._log(\"    MATCHED: \" + JSON.stringify(found));\n          }\n\n          /*  pattern found, so give action a chance to operate\n              on it and act according to its results  */\n          this._ctx._match = found;\n          this._ctx._repeat = false;\n          this._ctx._reject = false;\n          this._ctx._ignore = false;\n\n          if (this._before !== null) {\n            this._before.call(this._ctx, this._ctx, found, $rule);\n          }\n\n          $rule._action.call(this._ctx, this._ctx, found, $rule);\n\n          if (this._after !== null) {\n            this._after.call(this._ctx, this._ctx, found, $rule);\n          }\n\n          /*  reject current action, continue matching  */\n          if (this._ctx._reject) {\n            continue;\n          }\n\n          /*  repeat matching from scratch  */\n          if (this._ctx._repeat) {\n            continued = true;\n            break;\n          }\n\n          /*  ignore token  */\n          if (this._ctx._ignore) {\n            this._progress(this._pos, $rule._pattern.lastIndex);\n            this._pos = $rule._pattern.lastIndex;\n\n            if (this._pos >= this._len) {\n              finish();\n              return;\n            }\n\n            continued = true;\n            break;\n          }\n\n          /*  accept token(s)  */\n          if (this._pending.length > 0) {\n            this._progress(this._pos, $rule._pattern.lastIndex);\n            this._pos = $rule._pattern.lastIndex;\n\n            if (this._pos >= this._len) {\n              finish();\n            }\n\n            return;\n          }\n\n          /*  nothing worked  */\n          throw new Error(\n            `action of pattern \"${$rule._pattern.source}\" neither rejected nor accepted any token(s)`\n          );\n        }\n      }\n    }\n\n    /*  no pattern matched at all  */\n    throw this.error(\"token not recognized\");\n  }\n\n  /**\n   * Progress the line/column counter\n   */\n  private _progress(from: number, until: number): void {\n    const line = this._line;\n    const column = this._column;\n    const s = this._input;\n\n    for (let i = from; i < until; i++) {\n      const c = s.charAt(i);\n\n      if (c === \"\\r\") {\n        this._column = 1;\n      } else if (c === \"\\n\") {\n        this._line++;\n        this._column = 1;\n      } else if (c === \"\\t\") {\n        this._column += 8 - (this._column % 8);\n      } else {\n        this._column++;\n      }\n    }\n\n    this._log(\n      `    PROGRESS: characters: ${until - from}, ` +\n        `from: <line ${line}, column ${column}>, ` +\n        `to: <line ${this._line}, column ${this._column}>`\n    );\n  }\n}\n"],"names":["Token","type","value","text","pos","line","column","this","toString","JSON","stringify","join","isA","ActionContext","tokenizr","_tokenizr","data","key","_data","info","_line","_column","_pos","len","_match","length","NaN","push","state","pop","tag","tagged","untag","repeat","_log","_repeat","reject","_reject","ignore","_ignore","accept","Error","_pending","stop","_stopped","hex","ch","charCodeAt","toUpperCase","extract","txt","substr","replace","excerpt","offset","textLength","start","end","prologTrunc","prologText","tokenText","epilogText","epilogTrunc","ParsingError","message","input","_this","name","l","prefix1","prefix2","i","MatchResult","execArray","matched","index","Object","entries","forEach","result","map","find","filter","includes","assertIsString","error","AssertionError","expected","actual","StateStack","defaultState","elements","clear","isEmpty","peek","Stack","init","element","stack","isNotEmpty","undefined","State","stateDef","pieces","split","states","p","startsWith","tags","piece","default","create","taggedState","stringifyTags","is","matches","a1","a2","item","reduce","a","c","filterTags","cb","hasTag","unTag","indexOf","Rule","test","_pattern","exec","query","_states","hasState","s","getState","getStates","setName","_name","setAction","action","_action","setState","stateDefs","addState","setPattern","pattern","flags","RegExp","sticky","ex","multiline","dotAll","ignoreCase","unicode","source","Tokenizr","config","defaults","_state","_ctx","reset","_input","_len","_eof","_transaction","debug","oldState","_tag","before","_before","after","_after","finish","_finish","rule","compile","_rules","ignoreRule","ctx","token","_tokenize","shift","tokens","tokenGenerator","tokenize","contents","skip","consume","raiseError","expectedValue","expectedType","begin","unshift","depth","commit","rollback","concat","alternatives","depths","call","sort","b","msg","console","log","_this2","continued","e","keys","$rule","statesMatch","currentState","willMatchAnyState","matchedState","isTagged","lastIndex","found","_progress","from","until","charAt"],"mappings":"wBAAaA,aAQX,WACEC,EACAC,EACAC,EACAC,EACAC,EACAC,YAFAF,IAAAA,EAAM,YACNC,IAAAA,EAAO,YACPC,IAAAA,EAAS,GAETC,KAAKN,KAAOA,EACZM,KAAKL,MAAQA,EACbK,KAAKJ,KAAOA,EACZI,KAAKH,IAAMA,EACXG,KAAKF,KAAOA,EACZE,KAAKD,OAASA,EArBlB,2BAwBEE,SAAA,WAUE,UATkB,UACPD,KAAKN,eACJQ,KAAKC,UAAUH,KAAKL,gBACrBO,KAAKC,UAAUH,KAAKJ,cACrBI,KAAKH,aACJG,KAAKF,gBACHE,KAAKD,QAChBK,KAAK,aAKTC,IAAA,SAAIX,EAAcC,GAChB,OAAID,IAASM,KAAKN,QAIdC,GAASA,IAAUK,KAAKL,aCvCnBW,aAQX,WAAYC,GANZP,cAAU,EACVA,cAAU,EACVA,cAAU,EACVA,WAAiC,GACjCA,YAAiC,KAG/BA,KAAKQ,UAAYD,EATrB,2BAiBEE,KAAA,SAAKC,EAAaf,GAChB,YAAqB,IAAVA,OACGgB,MAAMD,IAGpBV,KAAKW,MAAMD,GAAOf,SAQpBiB,KAAA,WAQE,MAAO,CACLd,KAAME,KAAKQ,UAAUK,MACrBd,OAAQC,KAAKQ,UAAUM,QACvBjB,IAAKG,KAAKQ,UAAUO,KACpBC,IANUhB,KAAKiB,OAASjB,KAAKiB,OAAO,GAAGC,OAASC,QAapDC,KAAA,SAAKC,GAGH,OAFArB,KAAKQ,UAAUY,KAAKC,WAQtBC,IAAA,WAGE,OAFAtB,KAAKQ,UAAUc,cAUjBD,MAAA,SAAMA,GACJ,YAAqB,IAAVA,OACGb,UAAUa,SAGxBrB,KAAKQ,UAAUa,MAAMA,YAQvBE,IAAA,SAAIA,GAGF,OAFAvB,KAAKQ,UAAUe,IAAIA,WAQrBC,OAAA,SAAOD,GACL,YAAYf,UAAUgB,OAAOD,MAM/BE,MAAA,SAAMF,GAGJ,OAFAvB,KAAKQ,UAAUiB,MAAMF,WAQvBG,OAAA,WAIE,OAHA1B,KAAKQ,UAAUmB,KAAK,cACpB3B,KAAK4B,SAAU,UAQjBC,OAAA,WAIE,OAHA7B,KAAKQ,UAAUmB,KAAK,cACpB3B,KAAK8B,SAAU,UAQjBC,OAAA,WAIE,OAHA/B,KAAKQ,UAAUmB,KAAK,cACpB3B,KAAKgC,SAAU,UAUjBC,OAAA,SAAOvC,EAAcC,GACnB,GAAoB,OAAhBK,KAAKiB,OACP,MAAMiB,MAAM,iDA0Bd,YAvBqB,IAAVvC,IAETA,EAAQK,KAAKiB,OAAO,IAGtBjB,KAAKQ,UAAUmB,KACb,qBAAqBjC,cAChBQ,KAAKC,UAAUR,eAAkBA,eAClCK,KAAKiB,OAAO,QAIlBjB,KAAKQ,UAAU2B,SAASf,KACtB,IAAI3B,EACFC,EACAC,EACAK,KAAKiB,OAAO,GACZjB,KAAKQ,UAAUO,KACff,KAAKQ,UAAUK,MACfb,KAAKQ,UAAUM,kBAUrBsB,KAAA,WAGE,OAFApC,KAAKQ,UAAU6B,UAAW,gpDC9K9B,SAASC,EAAIC,GACX,OAAOA,EAAGC,WAAW,GAAGvC,SAAS,IAAIwC,cAGvC,SAASC,EAAQC,EAAa9C,EAAamB,GACzC,OAAO2B,EACJC,OAAO/C,EAAKmB,GACZ6B,QAAQ,MAAO,QACfA,QAAQ,QAAS,OACjBA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,MAAO,OACfA,QAAQ,2BAA4B,SAAAN,SAAM,OAASD,EAAIC,KACvDM,QAAQ,wBAAyB,SAAAN,SAAM,MAAQD,EAAIC,KACnDM,QAAQ,mBAAoB,SAAAN,SAAM,OAASD,EAAIC,KAC/CM,QAAQ,mBAAoB,SAAAN,SAAM,MAAQD,EAAIC,KAMnD,SAAgBO,EAAQH,EAAaI,GACnC,IAAMC,EAAaL,EAAIzB,OAEnB+B,EAAQF,EAAS,GACjBE,EAAQ,IAAGA,EAAQ,GAEvB,IAAIC,EAAMH,EAAS,GAGnB,OAFIG,EAAMF,IAAYE,EAAMF,GAErB,CACLG,YAAaF,EAAQ,EACrBG,WAAYV,EAAQC,EAAKM,EAAOF,EAASE,GACzCI,UAAWX,EAAQC,EAAKI,EAAQ,GAChCO,WAAYZ,EAAQC,EAAKI,EAAS,EAAGG,GAAOH,EAAS,IACrDQ,YAAaL,EAAMF,OCrCVQ,cAMX,WACEC,EACA5D,EACAC,EACAC,EACA2D,gBAEAC,cAAMF,UAEDG,KAAO,eACZD,EAAKF,QAAUA,EACfE,EAAK9D,IAAMA,EACX8D,EAAK7D,KAAOA,EACZ6D,EAAK5D,OAASA,EACd4D,EAAKD,MAAQA,8BAMfzD,SAAA,WAME,IALA,IAAM4D,EAAIf,EAAQ9C,KAAK0D,MAAO1D,KAAKH,KAC7BiE,UAAkB9D,KAAKF,iBAAgBE,KAAKD,aAE9CgE,EAAU,GAELC,EAAI,EAAGA,EAAIF,EAAQ5C,OAAS2C,EAAET,WAAWlC,OAAQ8C,IACxDD,GAAW,IAcb,MAXE,kBACA/D,KAAKyD,QACL,KACAK,EACAD,EAAET,WACFS,EAAER,UACFQ,EAAEP,WACF,KACAS,EACA,UA7C4B7B,QCFrB+B,EAaX,SAAYC,cAZZlE,cAAU,EAIVA,YAAmB,IASZA,KAAKmE,QAAwB,OAAdD,KAClBlE,KAAK0D,MAAQQ,EAAUR,MACvB1D,KAAKoE,MAAQF,EAAUE,MAEvBC,OAAOC,QAAQJ,GAAWK,QAAQ,gBAAE7D,OACtB,WAARA,GAA4B,UAARA,GAA2B,UAARA,GACzCiD,EAAKa,OAAOpD,cAKlBpB,KAAKyE,IAAMzE,KAAKwE,OAAOC,IACvBzE,KAAK0E,KAAO1E,KAAKwE,OAAOE,KACxB1E,KAAK2E,OAAS3E,KAAKwE,OAAOG,OAC1B3E,KAAKkB,OAASlB,KAAKwE,OAAOtD,OAC1BlB,KAAK4E,SAAW5E,KAAKwE,OAAOI,UCvBhC,SAAgBC,EACdnB,EACAoB,GAEA,GAAqB,iBAAVpB,EACT,UAAUqB,iBAAe,CACvBC,SAAU,SACVC,cAAevB,EACfD,QAASqB,GAAS,0CCZXI,cACX,WAAoBC,gBAClBxB,mCADkBwB,EAElBxB,EAAKwB,aAAeA,EACpBxB,EAAKyB,SAAShE,KAAKuC,EAAKwB,uBAJ5B,2BAWEE,MAAA,WACErF,KAAKoF,SAAW,CAACpF,KAAKmF,iBAGxB7D,IAAA,WACE,GAAItB,KAAKsF,QACP,MAAMpD,8CACoClC,KAAKmF,kBAIjD,YAAYC,SAAS9D,SAGvBiE,KAAA,WACE,YAAYH,SAASpF,KAAKoF,SAASlE,OAAS,uCAlB5C,OAAgC,SAApBkE,SAASlE,yBCVzB,aASYlB,cAAgB,GAT5BwF,EACSC,KAAP,SAAeC,GACb,IAAMC,EAAQ,IAAIH,EAIlB,OAFAG,EAAMvE,KAAKsE,GAEJC,8BAiBTN,MAAA,WACErF,KAAKoF,SAAW,MAGlBhE,KAAA,SAAKsE,GACH,YAAYN,SAAShE,KAAKsE,MAG5BpE,IAAA,WACE,YAAY8D,SAAS9D,SAGvBiE,KAAA,WACE,YAAYK,WAAa5F,KAAKoF,SAASpF,KAAKkB,OAAS,QAAK2E,qCAxB1D,YAAYT,SAASlE,uCAIrB,OAAuB,SAAXA,0CAIZ,OAAQlB,KAAKsF,kBClBJQ,aAgBX,WAAYC,GAPZ/F,UAAO,UACPA,UAAiB,GAOf,IAAMgG,EAASD,EAASE,MAAM,QACxBC,EAASF,EAAOrB,OAAO,SAAAwB,UAAMA,EAAEC,WAAW,OAEhD,GAAsB,IAAlBF,EAAOhF,OACT,UAAUgB,MAAM,8BAGlBlC,KAAK4D,KAAOsC,EAAO,GACnBlG,KAAKqG,KAAOL,EACTrB,OAAO,SAAA2B,UAASA,EAAMF,WAAW,OACjC3B,IAAI,SAAAlD,UAAOA,EAAIsB,QAAQ,IAAK,MA3BnCiD,EACSS,QAAP,WACE,WAAWT,EAAM,cAGZU,OAAP,SAAcC,GACZ,WAAWX,EAAMW,+BAwBnBxG,SAAA,WACE,YAAe2D,SAAQ5D,KAAK0G,mBAG9BA,cAAA,WACE,YAAYL,KAAK5B,IAAI,SAAAlD,aAAWA,IAAOnB,KAAK,QAM9CuG,GAAA,SAAGtF,GACD,YAAYuC,OAASvC,KAMvBuF,QAAA,SAAQvF,GACN,YACOuC,OAASvC,EAAMuC,QCpDEiD,EDoDkB7G,KAAKqG,SCpDRS,EDoDczF,EAAMgF,OC/CzDQ,EAAG3F,SAAW4F,EAAG5F,QAId2F,EACJpC,IAAI,SAAAsC,UAAQD,EAAGlC,SAASmC,KACxBC,OAAO,SAACC,EAAGC,UAAMD,GAAKC,IAAG,QAXFL,EAAeC,KDwDzCK,WAAA,SAAWC,GACT,YAAYf,KAAK1B,OAAOyC,MAG1BC,OAAA,SAAO9F,GACL,YAAY8E,KAAKzB,SAASrD,MAG5BA,IAAA,SAAIA,GAGF,OAFAvB,KAAKqG,KAAKjF,KAAKG,WAKjB+F,MAAA,SAAM/F,GAGJ,mBAFY8E,KAAKrG,KAAKqG,KAAKkB,QAAQhG,8CAxDnC,YAAY8E,KAAKnF,OAAS,WEVjBsG,aAAb,aAEExH,WAAQ,UAERA,aAAmB,GAGnBA,eAA8C,GAPhD,2BAgCEyH,KAAA,SAAK/D,GACH,WAAWO,EAAYjE,KAAK0H,SAASC,KAAKjE,OAG5CrC,MAAA,SAAMuG,GAGJ,OAFA/C,EAAe+C,QAEHC,QAAQnD,KAAK,SAAArD,UAASA,EAAMuC,OAASgE,OAGnDE,SAAA,SAASzG,GACP,YAAYwG,QAAQlD,OAAO,SAAAoD,UAAKA,EAAEpB,GAAGtF,KAAQH,OAAS,KAGxD8G,SAAA,SAAS3G,GACP,IAAKrB,KAAK8H,SAASzG,GACjB,MAAMa,QAGR,YAAY2F,QAAQnD,KAAK,SAAAqD,UAAKA,EAAEpB,GAAGtF,QAGrC4G,UAAA,WACE,YAAYJ,QAAQpD,IAAI,SAAAsC,UAAQA,EAAKnD,UAMvCsE,QAAA,SAAQtE,GAGN,OAFA5D,KAAKmI,MAAQvE,UAQfwE,UAAA,SAAUC,GAGR,OAFArI,KAAKsI,QAAUD,UAcjBE,SAAA,SAAS7E,GACP,IAAM8E,EAAY9E,EAAMuC,MAAM,YAI9B,OAFAjG,KAAK6H,QAAUW,EAAU/D,IAAIqB,EAAMU,gBAcrCiC,SAAA,SAAS/E,GAGP,OAFA1D,KAAK6H,QAAQzG,KAAK,IAAI0E,EAAMpC,YAK9BgF,WAAA,SAAWC,GAET,IAAIC,EAAQ,IAEZ,IAE+B,kBADd,IAAIC,OAAO,GAAI,KACZC,SAEhBF,EAAQ,KAEV,MAAOG,IAeT,MAXiC,kBAAtBJ,EAAQK,WAA2BL,EAAQK,YACpDJ,GAAS,KACmB,kBAAnBD,EAAQM,QAAwBN,EAAQM,SACjDL,GAAS,KACuB,kBAAvBD,EAAQO,YAA4BP,EAAQO,aACrDN,GAAS,KACoB,kBAApBD,EAAQQ,SAAyBR,EAAQQ,UAClDP,GAAS,KAEX5I,KAAK0H,SAAW,IAAImB,OAAOF,EAAQS,OAAQR,2CAzH3C,YAAYf,QAAQpD,IAAI,SAAApD,UAASA,EAAMpB,uDAIvC,YAAY6H,SAAS,wCAIrB,YAAgC,SAAbJ,2CAInB,YAA+B,SAAZY,wCAInB,YAA6B,SAAVH,eCjBVkB,aA0BX,WAAYC,GAnBZtJ,UAAO,EACPA,UAAO,EACPA,WAAQ,EACRA,aAAU,EACVA,YAAS,GACTA,WAAO,EACPA,eAAW,EAEXA,YAAiB,GACjBA,cAAoB,GACpBA,YAAwB,KACxBA,aAAyB,KACzBA,aAA+B,KAG/BA,UAAa,GAEbA,kBAA0B,GAGxBA,KAAKsJ,YAAcD,EAASE,SAAaD,GAEzCtJ,KAAKwJ,OAAS,IAAItE,EAAW,WAE7BlF,KAAKyJ,KAAO,IAAInJ,EAAcN,MA/BlC,2BAqCE0J,MAAA,WAiBE,OAhBA1J,KAAK2J,OAAS,GACd3J,KAAK4J,KAAO,EACZ5J,KAAK6J,MAAO,EACZ7J,KAAKe,KAAO,EACZf,KAAKa,MAAQ,EACbb,KAAKc,QAAU,EAGfd,KAAK8J,aAAe,GACpB9J,KAAKmC,SAAW,GAChBnC,KAAKqC,UAAW,EAEhBrC,KAAKwJ,OAAOnE,QAEZrF,KAAKyJ,KAAO,IAAInJ,EAAcN,cAQhC8E,MAAA,SAAMrB,GACJ,WAAWD,EACTC,EACAzD,KAAKe,KACLf,KAAKa,MACLb,KAAKc,QACLd,KAAK2J,WAOTI,MAAA,SAAMA,GAGJ,OAFA/J,KAAKsJ,OAAOS,MAAQA,UAQtBrG,MAAA,SAAMA,GAQJ,OAPAmB,EAAenB,GAEf1D,KAAK0J,QAEL1J,KAAK2J,OAASjG,EACd1D,KAAK4J,KAAOlG,EAAMxC,eAQpBE,KAAA,SAAKC,GACH,IAAM2I,EAAWhK,KAAKwJ,OAAOjE,OAM7B,OAJAvF,KAAKwJ,OAAOpI,KAAKC,GAEjBrB,KAAK2B,gCAAgCqI,cAAoB3I,eAQ3DC,IAAA,WACE,GAAItB,KAAKwJ,OAAOtI,OAAS,EACvB,UAAUgB,MAAM,gCAIlB,IAAM8H,EAAWhK,KAAKwJ,OAAOlI,MAM7B,OAJAtB,KAAK2B,+BACuBqI,cAAoBhK,KAAKwJ,OAAOjE,oBAW9DlE,MAAA,SAAMA,GACJ,YAAqB,IAAVA,OACGmI,OAAOjE,QAGrBvF,KAAK2B,KACH,0BACW3B,KAAKwJ,OAAOjE,OADvB,YAEWlE,OAGbrB,KAAKwJ,OAAOpI,KAAKC,YAQnBE,IAAA,SAAIA,GAGF,OAFAvB,KAAKiK,KAAK1I,IAAO,EACjBvB,KAAK2B,uBAAuBJ,WAO9BC,OAAA,SAAOD,GACL,OAA0B,SAAd0I,KAAK1I,MAMnBE,MAAA,SAAMF,GAGJ,mBAFY0I,KAAK1I,GACjBvB,KAAK2B,uBAAuBJ,WAO9B2I,OAAA,SAAO7B,GAEL,OADArI,KAAKmK,QAAU9B,UAOjB+B,MAAA,SAAM/B,GAEJ,OADArI,KAAKqK,OAAShC,UAOhBiC,OAAA,SAAOjC,GAEL,OADArI,KAAKuK,QAAUlC,UA+BjBmC,KAAA,SACEnJ,EACAsH,EACAN,EACAzE,YADAyE,IAAAA,EAA0B,oBAC1BzE,IAAAA,EAAO,WAEP,IAAM4G,EAAO,IAAIhD,EAiCjB,MA/BqB,iBAAVnG,EACTmJ,EAAKjC,SAASlH,IAEdmJ,EAAKjC,SAAS,WACdiC,EAAK9B,WAAWrH,SNpPoB,IMuPzBsH,ENvPa8B,QMwPxBD,EAAK9B,WAAWC,GAEhB6B,EAAKpC,UAAUO,GAGK,iBAAXN,EACTmC,EAAKtC,QAAQG,GAEbmC,EAAKpC,UAAUC,GAGG,iBAATzE,GACT4G,EAAKtC,QAAQtE,GAGf5D,KAAK0K,OAAOtJ,KAAKoJ,GAEbxK,KAAKsJ,OAAOS,OACd/J,KAAK2B,qCAC6B6I,EAAKtE,qBAAoBsE,EAAK9C,SAAS0B,oBAU7EuB,WAAA,SAAWhC,GACT,YAAY6B,KAAK7B,EAAS,SAAAiC,UAAOA,EAAI7I,cAMvC8I,MAAA,WAOE,GAL6B,IAAzB7K,KAAKmC,SAASjB,QAChBlB,KAAK8K,YAIH9K,KAAKmC,SAASjB,OAAS,EAAG,CAC5B,IAAM2J,EAAQ7K,KAAKmC,SAAS4I,QAE5B,GAAIF,EAOF,OANI7K,KAAK8J,aAAa5I,OAAS,GAC7BlB,KAAK8J,aAAa,GAAG1I,KAAKyJ,GAG5B7K,KAAK2B,eAAekJ,EAAM5K,YAEnB4K,EAKX,eAMFG,OAAA,WAKE,IAJA,IAEIH,EAFErG,EAAkB,GAIU,QAA1BqG,EAAQ7K,KAAK6K,UAAmBrG,EAAOpD,KAAKyJ,GAEpD,OAAOrG,KAMRyG,uCAAD,qGAGoC,QAA1BJ,EAAQ7K,KAAK6K,yBACnB,gBAAMA,EAJV,qEAWAK,SAAA,SAASC,GAGP,OAFAnL,KAAK0D,MAAMyH,QAECH,YAMdzF,KAAA,SAAKxC,YAAAA,IAAAA,EAAS,GACZ,IAAK,IAAIiB,EAAI,EAAGA,EAAIhE,KAAKmC,SAASjB,OAAS6B,EAAQiB,IACjDhE,KAAK8K,YAGP,GAAI/H,GAAU/C,KAAKmC,SAASjB,OAC1B,UAAUgB,MAAM,kDAKlB,OAFAlC,KAAK2B,cAAc3B,KAAKmC,SAASY,GAAQ9C,iBAE7BkC,SAASY,MAMvBqI,KAAA,SAAKpK,YAAAA,IAAAA,EAAM,GACT,IAAK,IAAIgD,EAAI,EAAGA,EAAIhE,KAAKmC,SAASjB,OAASF,EAAKgD,IAC9ChE,KAAK8K,YAGP,GAAI9J,EAAMhB,KAAKmC,SAASjB,OACtB,UAAUgB,MAAM,kDAIlB,KAAOlB,KAAQ,GACbhB,KAAK6K,QAGP,eAMFQ,QAAA,SAAQ3L,EAAcC,GACpB,eAASqE,EAAI,EAAGA,EAAIhE,KAAKmC,SAASjB,OAAS,EAAG8C,IAC5ChE,KAAK8K,YAGP,GAA6B,IAAzB9K,KAAKmC,SAASjB,OAChB,UAAUgB,MACR,qDAIJ,IAAM2I,EAAQ7K,KAAK6K,QAEnB7K,KAAK2B,iBAAiBkJ,EAAM5K,YAE5B,IAAMqL,EAAa,SACjBC,EACAC,GAEA,UAAUhI,EACR,oBAAoB9D,cAAgBQ,KAAKC,UACvCoL,QACIC,EAFN,qBAGmBX,EAAMnL,iBAAgBQ,KAAKC,UAC1C0K,EAAMlL,mBACKkL,EAAMlL,WACrBkL,EAAMhL,IACNgL,EAAM/K,KACN+K,EAAM9K,OACN4D,EAAKgG,SAUT,OANIhK,IAAUkL,EAAMxK,IAAIX,EAAMC,GAC5B2L,EAAW3L,SAAcA,GACfkL,EAAMxK,IAAIX,IACpB4L,EAAW,IAAK,OAGXT,KAMTY,MAAA,WAKE,OAJAzL,KAAK2B,qBAAqB3B,KAAK8J,aAAa5I,QAE5ClB,KAAK8J,aAAa4B,QAAQ,YAQ5BC,MAAA,WACE,GAAiC,IAA7B3L,KAAK8J,aAAa5I,OACpB,UAAUgB,MACR,mDAIJ,YAAY4H,aAAa,GAAG5I,UAM9B0K,OAAA,WACE,GAAiC,IAA7B5L,KAAK8J,aAAa5I,OACpB,UAAUgB,MACR,sDAQJ,OAJAlC,KAAK8J,aAAaiB,QAElB/K,KAAK2B,sBAAsB3B,KAAK8J,aAAa5I,gBAQ/C2K,SAAA,WACE,GAAiC,IAA7B7L,KAAK8J,aAAa5I,OACpB,UAAUgB,MACR,wDAUJ,OANAlC,KAAKmC,SAAWnC,KAAK8J,aAAa,GAAGgC,OAAO9L,KAAKmC,UAEjDnC,KAAK8J,aAAaiB,QAElB/K,KAAK2B,wBAAwB3B,KAAK8J,aAAa5I,gBAQjD6K,aAAA,WAME,QALGA,2BAECvH,EAAkB,KAClBwH,EAAuB,GAElBhI,EAAI,EAAGA,EAAI+H,EAAa7K,OAAQ8C,IACvC,IACEhE,KAAKyL,QACLjH,EAASuH,EAAa/H,GAAGiI,KAAKjM,KAAMA,MACpCA,KAAK4L,SACL,MACA,MAAO9G,GACPkH,EAAO5K,KAAK,CACV0D,MAAAA,EACA6G,MAAO3L,KAAK2L,UAEd3L,KAAK6L,WACL7L,KAAK2B,mBAAmBmD,EAAM7E,YAC9B,SAIJ,GAAe,OAAXuE,GAAmBwH,EAAO9K,OAAS,EAGrC,MAFA8K,EAASA,EAAOE,KAAK,SAACjF,EAAGkF,UAAMlF,EAAE0E,MAAQQ,EAAER,SAE9B,GAAG7G,MAGlB,OAAON,KAMT7C,KAAA,SAAKyK,GACCpM,KAAKsJ,OAAOS,OAEdsC,QAAQC,iBAAiBF,MAOrBtB,UAAA,sBAEAR,EAAS,WACRiC,EAAK1C,OACa,OAAjB0C,EAAKhC,SACPgC,EAAKhC,QAAQ0B,KAAKM,EAAK9C,KAAM8C,EAAK9C,MAGpC8C,EAAK1C,MAAO,EAEZ0C,EAAKpK,SAASf,KACZ,IAAI3B,EAAM,MAAO,GAAI,GAAI8M,EAAKxL,KAAMwL,EAAK1L,MAAO0L,EAAKzL,YAM3D,KAAId,KAAKqC,UAAYrC,KAAKe,MAAQf,KAAK4J,MAAvC,CAOA,IADA,IAAI4C,GAAY,EACTA,GAAW,CAIhB,GAHAA,GAAY,EAGRxM,KAAKsJ,OAAOS,MAAO,CACrB,IAAM0C,EAAI3J,EAAQ9C,KAAK2J,OAAQ3J,KAAKe,MAC9BsF,EAAOhC,OAAOqI,KAAK1M,KAAKiK,MAC3BxF,IAAI,SAAAlD,aAAWA,IACfnB,KAAK,KAERJ,KAAK2B,KACH,kBAAkB3B,KAAKwJ,OAAOjE,oBAAmBc,eAC9CoG,EAAEtJ,YAAc,MAAQ,KACtBsJ,EAAErJ,eAAcqJ,EAAEpJ,cAAaoJ,EAAEnJ,YACnCmJ,EAAElJ,YAAc,MAAQ,oBACVvD,KAAKa,kBAAiBb,KAAKc,aAKhD,IAAK,IAAIkD,EAAI,EAAGA,EAAIhE,KAAK0K,OAAOxJ,OAAQ8C,IAAK,CAC3C,IAAM2I,EAAQ3M,KAAK0K,OAAO1G,GAE1B,GAAIhE,KAAKsJ,OAAOS,MAAO,CACrB,IAAI1I,EAAQsL,EAAMzG,OAAO,GAErByG,EAAMzG,OAAOhF,OAAS,IACxBG,EAAQsL,EAAMzG,OAAO9F,KAAK,OAG5BJ,KAAK2B,2BACmBN,iBAAoBsL,EAAMjF,SAAS0B,QAK7D,IAAIxC,GAAU,EACVgG,GAAc,EAEZC,EAAe7M,KAAKwJ,OAAOjE,OASjC,IALgC,IAA5BoH,EAAMG,oBACRF,EAAcD,EAAM7E,SAAS+E,IAI3BD,EAAa,CACfhG,GAAU,EAEV,IAAMmG,EAAeJ,EAAM3E,SAAS6E,GAEhCE,EAAaC,UACFD,EAAa5F,WACxB,SAAA5F,UAAQgL,EAAKtC,KAAK1I,KAGXL,OAAS,IAChB0F,GAAU,GAKhB,GAAKA,EAAL,CAGA+F,EAAMjF,SAASuF,UAAYjN,KAAKe,KAChC,IAAImM,EAAQP,EAAMjF,SAASC,KAAK3H,KAAK2J,QAGrC,GAFAgD,EAAMjF,SAASuF,UAAYjN,KAAKe,KAGiB,QAA9CmM,EAAQP,EAAMjF,SAASC,KAAK3H,KAAK2J,UAClCuD,EAAM9I,QAAUpE,KAAKe,KACrB,CAuBA,GAtBIf,KAAKsJ,OAAOS,OACd/J,KAAK2B,KAAK,gBAAkBzB,KAAKC,UAAU+M,IAK7ClN,KAAKyJ,KAAKxI,OAASiM,EACnBlN,KAAKyJ,KAAK7H,SAAU,EACpB5B,KAAKyJ,KAAK3H,SAAU,EACpB9B,KAAKyJ,KAAKzH,SAAU,EAEC,OAAjBhC,KAAKmK,SACPnK,KAAKmK,QAAQ8B,KAAKjM,KAAKyJ,KAAMzJ,KAAKyJ,KAAMyD,EAAOP,GAGjDA,EAAMrE,QAAQ2D,KAAKjM,KAAKyJ,KAAMzJ,KAAKyJ,KAAMyD,EAAOP,GAE5B,OAAhB3M,KAAKqK,QACPrK,KAAKqK,OAAO4B,KAAKjM,KAAKyJ,KAAMzJ,KAAKyJ,KAAMyD,EAAOP,GAI5C3M,KAAKyJ,KAAK3H,QACZ,SAIF,GAAI9B,KAAKyJ,KAAK7H,QAAS,CACrB4K,GAAY,EACZ,MAIF,GAAIxM,KAAKyJ,KAAKzH,QAAS,CAIrB,GAHAhC,KAAKmN,UAAUnN,KAAKe,KAAM4L,EAAMjF,SAASuF,WACzCjN,KAAKe,KAAO4L,EAAMjF,SAASuF,UAEvBjN,KAAKe,MAAQf,KAAK4J,KAEpB,YADAU,IAIFkC,GAAY,EACZ,MAIF,GAAIxM,KAAKmC,SAASjB,OAAS,EAQzB,OAPAlB,KAAKmN,UAAUnN,KAAKe,KAAM4L,EAAMjF,SAASuF,WACzCjN,KAAKe,KAAO4L,EAAMjF,SAASuF,eAEvBjN,KAAKe,MAAQf,KAAK4J,MACpBU,KAOJ,UAAUpI,4BACcyK,EAAMjF,SAAS0B,0DAO7C,WAAWtE,MAAM,wBApJfwF,OA0JI6C,UAAA,SAAUC,EAAcC,GAK9B,IAJA,IAAMvN,EAAOE,KAAKa,MACZd,EAASC,KAAKc,QACdiH,EAAI/H,KAAK2J,OAEN3F,EAAIoJ,EAAMpJ,EAAIqJ,EAAOrJ,IAAK,CACjC,IAAMkD,EAAIa,EAAEuF,OAAOtJ,GAET,OAANkD,EACFlH,KAAKc,QAAU,EACA,OAANoG,GACTlH,KAAKa,QACLb,KAAKc,QAAU,GACA,OAANoG,EACTlH,KAAKc,SAAW,EAAKd,KAAKc,QAAU,EAEpCd,KAAKc,UAITd,KAAK2B,KACH,8BAA6B0L,EAAQD,GAArC,iBACiBtN,cAAgBC,EADjC,gBAEeC,KAAKa,kBAAiBb,KAAKc,mBA3sB9BuI,WAAW,CACzBU,OAAO"}