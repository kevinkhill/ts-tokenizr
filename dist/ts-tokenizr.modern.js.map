{"version":3,"file":"ts-tokenizr.modern.js","sources":["../src/Token.ts","../src/ActionContext.ts","../src/lib/excerpt.ts","../src/lib/ParsingError.ts","../src/lib/MatchResult.ts","../src/lib/guards.ts","../src/lib/Stack.ts","../src/lib/StateStack.ts","../src/State.ts","../src/lib/arrayEquals.ts","../src/Rule.ts","../src/Tokenizr.ts"],"sourcesContent":["export class Token {\n  type: string;\n  value: unknown;\n  text: string;\n  pos: number;\n  line: number;\n  column: number;\n\n  constructor(\n    type: string,\n    value: unknown,\n    text: string,\n    pos = 0,\n    line = 0,\n    column = 0\n  ) {\n    this.type = type;\n    this.value = value;\n    this.text = text;\n    this.pos = pos;\n    this.line = line;\n    this.column = column;\n  }\n\n  toString(): string {\n    const tokenAttr = [\n      `type: ${this.type}`,\n      `value: ${JSON.stringify(this.value)}`,\n      `text: ${JSON.stringify(this.text)}`,\n      `pos: ${this.pos}`,\n      `line: ${this.line}`,\n      `column: ${this.column}`\n    ].join(\", \");\n\n    return `<${tokenAttr}>`;\n  }\n\n  isA(type: string, value?: unknown): boolean {\n    if (type !== this.type) {\n      return false;\n    }\n\n    if (value && value !== this.value) {\n      return false;\n    }\n\n    return true;\n  }\n}\n","import { Token } from \"./Token\";\nimport { Tokenizr } from \"./Tokenizr\";\n\nexport class ActionContext {\n  _tokenizr: Tokenizr;\n  _repeat = false;\n  _reject = false;\n  _ignore = false;\n  _data: Record<string, unknown> = {};\n  _match: RegExpExecArray | null = null;\n\n  constructor(tokenizr: Tokenizr) {\n    this._tokenizr = tokenizr;\n  }\n\n  /**\n   * Store and retrieve user data attached to context\n   */\n  data(key: string): unknown;\n  data(key: string, value: unknown): void;\n  data(key: string, value?: unknown): unknown | true {\n    if (typeof value === \"undefined\") {\n      return this._data[key];\n    }\n\n    this._data[key] = value;\n\n    return true;\n  }\n\n  /**\n   * Retrieve information of current matching\n   */\n  info(): {\n    line: number;\n    column: number;\n    pos: number;\n    len: number;\n  } {\n    const len = this._match ? this._match[0].length : NaN;\n\n    return {\n      line: this._tokenizr._line,\n      column: this._tokenizr._column,\n      pos: this._tokenizr._pos,\n      len\n    };\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  push(state: string): this {\n    this._tokenizr.push(state);\n\n    return this;\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  pop(): this {\n    this._tokenizr.pop();\n\n    return this;\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  state(): string;\n  state(state: string): this;\n  state(state?: string): this | string {\n    if (typeof state === \"undefined\") {\n      return this._tokenizr.state();\n    }\n\n    this._tokenizr.state(state);\n\n    return this;\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  tag(tag: string): this {\n    this._tokenizr.tag(tag);\n\n    return this;\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  tagged(tag: string): boolean {\n    return this._tokenizr.tagged(tag);\n  }\n\n  /**\n   * Pass-through to the attached tokenizer\n   */\n  untag(tag: string): this {\n    this._tokenizr.untag(tag);\n\n    return this;\n  }\n\n  /**\n   * Mark current matching to be repeated from scratch\n   */\n  repeat(): this {\n    this._tokenizr._log(\"    REPEAT\");\n    this._repeat = true;\n\n    return this;\n  }\n\n  /**\n   * Mark current matching to be rejected\n   */\n  reject(): this {\n    this._tokenizr._log(\"    REJECT\");\n    this._reject = true;\n\n    return this;\n  }\n\n  /**\n   * Mark current matching to be ignored\n   */\n  ignore(): this {\n    this._tokenizr._log(\"    IGNORE\");\n    this._ignore = true;\n\n    return this;\n  }\n\n  /**\n   * Accept current matching as a new token\n   */\n  accept(type: string): this;\n  accept(type: string, value: unknown): this;\n  accept(type: string, value?: unknown): this {\n    if (this._match === null) {\n      throw Error(\"this._match was null when trying to .accept()\");\n    }\n\n    if (typeof value === \"undefined\") {\n      // eslint-disable-next-line no-param-reassign\n      value = this._match[0];\n    }\n\n    this._tokenizr._log(\n      `    ACCEPT: type: ${type}, value: ` +\n        `${JSON.stringify(value)} (${typeof value}), text: \"${\n          this._match[0]\n        }\"`\n    );\n\n    this._tokenizr._pending.push(\n      new Token(\n        type,\n        value,\n        this._match[0],\n        this._tokenizr._pos,\n        this._tokenizr._line,\n        this._tokenizr._column\n      )\n    );\n\n    return this;\n  }\n\n  /**\n   * Immediately stop tokenization\n   */\n  stop(): this {\n    this._tokenizr._stopped = true;\n\n    return this;\n  }\n}\n","/* eslint-disable no-control-regex */\nimport { Excerpt } from \"../types\";\n\nfunction hex(ch: string): string {\n  return ch.charCodeAt(0).toString(16).toUpperCase();\n}\n\nfunction extract(txt: string, pos: number, len: number): string {\n  return txt\n    .substr(pos, len)\n    .replace(/\\\\/g, \"\\\\\\\\\")\n    .replace(/\\x08/g, \"\\\\b\")\n    .replace(/\\t/g, \"\\\\t\")\n    .replace(/\\n/g, \"\\\\n\")\n    .replace(/\\f/g, \"\\\\f\")\n    .replace(/\\r/g, \"\\\\r\")\n    .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, ch => \"\\\\x0\" + hex(ch))\n    .replace(/[\\x10-\\x1F\\x80-\\xFF]/g, ch => \"\\\\x\" + hex(ch))\n    .replace(/[\\u0100-\\u0FFF]/g, ch => \"\\\\u0\" + hex(ch))\n    .replace(/[\\u1000-\\uFFFF]/g, ch => \"\\\\u\" + hex(ch));\n}\n\n/**\n * Create a source excerpt\n */\nexport function excerpt(txt: string, offset: number): Excerpt {\n  const textLength = txt.length;\n\n  let start = offset - 20;\n  if (start < 0) start = 0;\n\n  let end = offset + 20;\n  if (end > textLength) end = textLength;\n\n  return {\n    prologTrunc: start > 0,\n    prologText: extract(txt, start, offset - start),\n    tokenText: extract(txt, offset, 1),\n    epilogText: extract(txt, offset + 1, end - (offset + 1)),\n    epilogTrunc: end < textLength\n  };\n}\n","import { excerpt } from \"./excerpt\";\n\nexport class ParsingError extends Error {\n  pos: number;\n  line: number;\n  column: number;\n  input: string;\n\n  constructor(\n    message: string,\n    pos: number,\n    line: number,\n    column: number,\n    input: string\n  ) {\n    super(message);\n\n    this.name = \"ParsingError\";\n    this.message = message;\n    this.pos = pos;\n    this.line = line;\n    this.column = column;\n    this.input = input;\n  }\n\n  /**\n   * Render a useful string representation\n   */\n  toString(): string {\n    const l = excerpt(this.input, this.pos);\n    const prefix1 = `line ${this.line} (column ${this.column}): `;\n\n    let prefix2 = \"\";\n\n    for (let i = 0; i < prefix1.length + l.prologText.length; i++)\n      prefix2 += \" \";\n\n    const msg =\n      \"Parsing Error: \" +\n      this.message +\n      \"\\n\" +\n      prefix1 +\n      l.prologText +\n      l.tokenText +\n      l.epilogText +\n      \"\\n\" +\n      prefix2 +\n      \"^\";\n\n    return msg;\n  }\n}\n","export class MatchResult {\n  matched = false;\n\n  input?: string;\n  index?: number;\n  result: string[] = [];\n\n  length: number;\n  map: string[][\"map\"];\n  find: string[][\"find\"];\n  filter: string[][\"filter\"];\n  includes: string[][\"includes\"];\n\n  constructor(execArray: RegExpExecArray | null) {\n    if ((this.matched = execArray !== null)) {\n      this.input = execArray.input;\n      this.index = execArray.index;\n\n      Object.entries(execArray).forEach(([key, value]) => {\n        if (key !== \"groups\" && key !== \"input\" && key !== \"index\") {\n          this.result.push(value);\n        }\n      });\n    }\n\n    this.map = this.result.map;\n    this.find = this.result.find;\n    this.filter = this.result.filter;\n    this.length = this.result.length;\n    this.includes = this.result.includes;\n  }\n}\n","import { AssertionError } from \"assert\";\n\nexport function isRegExp(o: unknown): o is RegExp {\n  return typeof (o as RegExp).compile !== \"undefined\";\n}\n\nexport function assertIsString(\n  input: unknown,\n  error?: string\n): asserts input is string {\n  if (typeof input !== \"string\") {\n    throw new AssertionError({\n      expected: \"string\",\n      actual: typeof input,\n      message: error || \"The given input must be a string.\"\n    });\n  }\n}\n","export class Stack<T> {\n  static init<T>(element: T): Stack<T> {\n    const stack = new Stack<T>();\n\n    stack.push(element);\n\n    return stack;\n  }\n\n  protected elements: T[] = [];\n\n  get length(): number {\n    return this.elements.length;\n  }\n\n  get isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  get isNotEmpty(): boolean {\n    return !this.isEmpty;\n  }\n\n  clear(): void {\n    this.elements = [];\n  }\n\n  push(element: T): number {\n    return this.elements.push(element);\n  }\n\n  pop(): T | undefined {\n    return this.elements.pop();\n  }\n\n  peek(): T | undefined {\n    return this.isNotEmpty ? this.elements[this.length - 1] : undefined;\n  }\n}\n","import { Stack } from \"./Stack\";\n\nexport class StateStack extends Stack<string> {\n  constructor(private defaultState: string) {\n    super();\n    this.defaultState = defaultState;\n    this.elements.push(this.defaultState);\n  }\n\n  get isEmpty(): boolean {\n    return this.elements.length === 1;\n  }\n\n  clear(): void {\n    this.elements = [this.defaultState];\n  }\n\n  pop(): string {\n    if (this.isEmpty) {\n      throw Error(\n        `ERROR: Cannot pop the default state \"${this.defaultState}\"`\n      );\n    }\n\n    return this.elements.pop() as string;\n  }\n\n  peek(): string {\n    return this.elements[this.elements.length - 1];\n  }\n}\n","import { arrayEquals } from \"./lib\";\n\nexport class State {\n  static default(): State {\n    return new State(\"default\");\n  }\n\n  static create(taggedState: string): State {\n    return new State(taggedState);\n  }\n\n  name = \"default\";\n  tags: string[] = [];\n\n  get isTagged(): boolean {\n    return this.tags.length > 0;\n  }\n\n  constructor(stateDef: string) {\n    const pieces = stateDef.split(/\\s+/g);\n    const states = pieces.filter(p => !p.startsWith(\"#\"));\n\n    if (states.length !== 1) {\n      throw new Error(\"exactly one state required\");\n    }\n\n    this.name = states[0];\n    this.tags = pieces\n      .filter(piece => piece.startsWith(\"#\"))\n      .map(tag => tag.replace(\"#\", \"\"));\n  }\n\n  toString(): string {\n    return `${this.name} ${this.stringifyTags()}`;\n  }\n\n  stringifyTags(): string {\n    return this.tags.map(tag => `#${tag}`).join(\" \");\n  }\n\n  /**\n   * Test if this state's name mathces the provided name\n   */\n  is(state: string): boolean {\n    return this.name === state;\n  }\n\n  /**\n   * Test if two State objects match\n   */\n  matches(state: State): boolean {\n    return (\n      this.name === state.name && arrayEquals(this.tags, state.tags)\n    );\n  }\n\n  filterTags(cb: (tag: string) => boolean): string[] {\n    return this.tags.filter(cb);\n  }\n\n  hasTag(tag: string): boolean {\n    return this.tags.includes(tag);\n  }\n\n  tag(tag: string): this {\n    this.tags.push(tag);\n\n    return this;\n  }\n\n  unTag(tag: string): this {\n    delete this.tags[this.tags.indexOf(tag)];\n\n    return this;\n  }\n}\n\nexport function statesMatch(\n  state1: string | State,\n  state2: string | State\n): boolean {\n  if (state1 instanceof State) {\n    // eslint-disable-next-line no-param-reassign\n    state1 = state1.name;\n  }\n\n  if (state2 instanceof State) {\n    // eslint-disable-next-line no-param-reassign\n    state2 = state2.name;\n  }\n\n  return state1 === state2;\n}\n","export function arrayEquals(a1: unknown[], a2: unknown[]): boolean {\n  if (a1 === a2) {\n    return true;\n  }\n\n  if (a1.length !== a2.length) {\n    return false;\n  }\n\n  return a1\n    .map(item => a2.includes(item))\n    .reduce((a, c) => a && c, true);\n}\n","import { assertIsString } from \"./lib/guards\";\nimport { MatchResult } from \"./lib/MatchResult\";\nimport { State } from \"./State\";\nimport { Action } from \"./types\";\n\nexport class Rule {\n  _action!: Action;\n  _name = \"unknown\";\n  _pattern!: RegExp;\n  _states: State[] = [];\n  // _tags: Array<string> = [];\n\n  stringify: Record<string, CallableFunction> = {};\n\n  get states(): string[] {\n    return this._states.map(state => state.toString());\n  }\n\n  get willMatchAnyState(): boolean {\n    return this.hasState(\"*\");\n  }\n\n  get hasPattern(): boolean {\n    return typeof this._pattern !== \"undefined\";\n  }\n\n  get hasAction(): boolean {\n    return typeof this._action !== \"undefined\";\n  }\n\n  get hasName(): boolean {\n    return typeof this._name !== \"undefined\";\n  }\n\n  /**\n   * Test a string against the {@link Rule}\n   */\n  test(input: string): MatchResult {\n    return new MatchResult(this._pattern.exec(input));\n  }\n\n  state(query?: string): State | undefined {\n    assertIsString(query);\n\n    return this._states.find(state => state.name === query);\n  }\n\n  hasState(state: string): boolean {\n    return this._states.filter(s => s.is(state)).length > 0;\n  }\n\n  getState(state: string): State {\n    if (!this.hasState(state)) {\n      throw Error();\n    }\n\n    return this._states.find(s => s.is(state)) as State;\n  }\n\n  getStates(): string[] {\n    return this._states.map(item => item.name);\n  }\n\n  /**\n   * Set the name for the Rule\n   */\n  setName(name: string): this {\n    this._name = name;\n\n    return this;\n  }\n\n  /**\n   * Set the {@link Action} for the {@link Rule}\n   */\n  setAction(action: Action): this {\n    this._action = action;\n\n    return this;\n  }\n\n  /**\n   * Set the state (and tags) for the Rule\n   *\n   * @example\n   * setState(\"*\")\n   * setState(\"default\")\n   * setState(\"comment #open\")\n   * setState(\"foo #bar, baz #qux\")\n   */\n  setState(input: string): this {\n    const stateDefs = input.split(/\\s*,\\s*/g);\n\n    this._states = stateDefs.map(State.create);\n\n    return this;\n  }\n\n  /**\n   * Add another matching state (and tags) for the Rule\n   *\n   * @example\n   * setState(\"*\")\n   * setState(\"default\")\n   * setState(\"comment #open\")\n   * setState(\"custom #foo #bar #baz\")\n   */\n  addState(input: string): this {\n    this._states.push(new State(input));\n\n    return this;\n  }\n\n  setPattern(pattern: RegExp): this {\n    /* ECMAScript <= 5 */\n    let flags = \"g\";\n\n    try {\n      const regexp = new RegExp(\"\", \"y\");\n      if (typeof regexp.sticky === \"boolean\") {\n        /* ECMAScript >= 2015 */\n        flags = \"y\";\n      }\n    } catch (ex) {\n      /*  no-op  */\n    }\n\n    if (typeof pattern.multiline === \"boolean\" && pattern.multiline)\n      flags += \"m\";\n    if (typeof pattern.dotAll === \"boolean\" && pattern.dotAll)\n      flags += \"s\";\n    if (typeof pattern.ignoreCase === \"boolean\" && pattern.ignoreCase)\n      flags += \"i\";\n    if (typeof pattern.unicode === \"boolean\" && pattern.unicode)\n      flags += \"u\";\n\n    this._pattern = new RegExp(pattern.source, flags);\n\n    return this;\n  }\n}\n","import { ActionContext } from \"./ActionContext\";\nimport { assertIsString, excerpt, isRegExp } from \"./lib\";\nimport { ParsingError } from \"./lib/ParsingError\";\nimport { StateStack } from \"./lib/StateStack\";\nimport { Rule } from \"./Rule\";\nimport { Token } from \"./Token\";\nimport {\n  Action,\n  DepthError,\n  FinishAction,\n  Tags,\n  TokenizrConfig\n} from \"./types\";\n\nexport class Tokenizr {\n  static readonly defaults = {\n    debug: false\n  };\n\n  config: TokenizrConfig;\n\n  _len = 0;\n  _pos = 0;\n  _line = 1;\n  _column = 1;\n  _input = \"\";\n  _eof = false;\n  _stopped = false;\n  _ctx: ActionContext;\n  _rules: Rule[] = [];\n  _pending: Token[] = [];\n  _after: Action | null = null;\n  _before: Action | null = null;\n  _finish: FinishAction | null = null;\n  // _tags: Array<string> = [];\n  _state: StateStack;\n  _tag: Tags = {};\n  // _state: Array<string> = [\"default\"];\n  _transaction: Token[][] = [];\n\n  constructor(config?: Partial<TokenizrConfig>) {\n    this.config = { ...Tokenizr.defaults, ...config };\n\n    this._state = new StateStack(\"default\");\n\n    this._ctx = new ActionContext(this);\n  }\n\n  /**\n   * Reset the internal state\n   */\n  reset(): this {\n    this._input = \"\";\n    this._len = 0;\n    this._eof = false;\n    this._pos = 0;\n    this._line = 1;\n    this._column = 1;\n    // this._state = [\"default\"];\n    // this._tag = {};\n    this._transaction = [];\n    this._pending = [];\n    this._stopped = false;\n\n    this._state.clear();\n\n    this._ctx = new ActionContext(this);\n\n    return this;\n  }\n\n  /**\n   * Create an error message for the current position\n   */\n  error(message: string): ParsingError {\n    return new ParsingError(\n      message,\n      this._pos,\n      this._line,\n      this._column,\n      this._input\n    );\n  }\n\n  /**\n   * Configure debug operation\n   */\n  debug(debug: boolean): this {\n    this.config.debug = debug;\n\n    return this;\n  }\n\n  /**\n   * Provide (new) input string to tokenize\n   */\n  input(input: string): this {\n    assertIsString(input);\n\n    this.reset();\n\n    this._input = input;\n    this._len = input.length;\n\n    return this;\n  }\n\n  /**\n   * Push state\n   */\n  push(state: string): this {\n    const oldState = this._state.peek();\n\n    this._state.push(state);\n\n    this._log(`    STATE (PUSH): old: <${oldState}>, new: <${state}>`);\n\n    return this;\n  }\n\n  /**\n   * Pop state from the stack\n   */\n  pop(): this {\n    if (this._state.length < 2) {\n      throw new Error(\"no more custom states to pop\");\n    }\n\n    /*  pop old state  */\n    const oldState = this._state.pop();\n\n    this._log(\n      `    STATE (POP): old: <${oldState}>, new: <${this._state.peek()}>`\n    );\n\n    return this;\n  }\n\n  /**\n   * get/set the state\n   */\n  state(): string;\n  state(state: string): this;\n  state(state?: string): this | string {\n    if (typeof state === \"undefined\") {\n      return this._state.peek();\n    }\n\n    this._log(\n      \"    STATE (SET): \" +\n        `old: <${this._state.peek()}>, ` +\n        `new: <${state}>`\n    );\n\n    this._state.push(state);\n\n    return this;\n  }\n\n  /**\n   * Set a tag\n   */\n  tag(tag: string): this {\n    this._tag[tag] = true;\n    this._log(`    TAG (ADD): ${tag}`);\n    return this;\n  }\n\n  /**\n   * Check whether tag is set\n   */\n  tagged(tag: string): boolean {\n    return this._tag[tag] === true;\n  }\n\n  /**\n   * Unset a tag\n   */\n  untag(tag: string): this {\n    delete this._tag[tag];\n    this._log(`    TAG (DEL): ${tag}`);\n    return this;\n  }\n\n  /**\n   * Configure a tokenization before-rule callback\n   */\n  before(action: Action): this {\n    this._before = action;\n    return this;\n  }\n\n  /**\n   * Configure a tokenization after-rule callback\n   */\n  after(action: Action): this {\n    this._after = action;\n    return this;\n  }\n\n  /**\n   * Configure a tokenization finish callback\n   */\n  finish(action: FinishAction): this {\n    this._finish = action;\n    return this;\n  }\n\n  /**\n   * Configure a tokenization rule\n   *\n   * Configure a token matching rule which executes its action if the\n   * current tokenization state is one of the states\n   * (and all of the currently set tags) in state (by default the rule\n   * matches all states if state is not specified) and the next input\n   * characters match against the pattern. The exact syntax of state is\n   * <state>[ #<tag> #<tag> ...][, <state>[ #<tag> #<tag> ...], ...]\n   *\n   * For example, it is one or more comma-separated state matches\n   * (OR-combined) and each state match has exactly one state and zero or more space-separated tags\n   * (AND-combined).\n   *\n   * The ctx argument provides a context object for token\n   * repeating/rejecting/ignoring/accepting and the match argument is\n   * the result of the underlying RegExp#exec call.\n   */\n  rule(state: RegExp, pattern: Action): this;\n  rule(state: RegExp, pattern: Action, action: string): this;\n  rule(state: string, pattern: RegExp, action: Action): this;\n  rule(\n    state: string,\n    pattern: RegExp,\n    action: Action,\n    name: string\n  ): this;\n  rule(\n    state: string | RegExp,\n    pattern: RegExp | Action,\n    action: Action | string = \"unknown\",\n    name = \"unknown\"\n  ): this {\n    const rule = new Rule();\n\n    if (typeof state === \"string\") {\n      rule.setState(state);\n    } else {\n      rule.setState(\"default\");\n      rule.setPattern(state);\n    }\n\n    if (isRegExp(pattern)) {\n      rule.setPattern(pattern);\n    } else {\n      rule.setAction(pattern);\n    }\n\n    if (typeof action === \"string\") {\n      rule.setName(action);\n    } else {\n      rule.setAction(action);\n    }\n\n    if (typeof name === \"string\") {\n      rule.setName(name);\n    }\n\n    this._rules.push(rule);\n\n    if (this.config.debug) {\n      this._log(\n        `rule: configure rule (state: ${rule.states}, pattern: ${rule._pattern.source})`\n      );\n    }\n\n    return this;\n  }\n\n  /**\n   * Sugar method for ignoring a token w/o defining an Action to ignore\n   */\n  ignoreRule(pattern: RegExp): this {\n    return this.rule(pattern, ctx => ctx.ignore());\n  }\n\n  /**\n   * Determine and return next token\n   */\n  token(): Token | null {\n    /*  if no more tokens are pending, try to determine a new one  */\n    if (this._pending.length === 0) {\n      this._tokenize();\n    }\n\n    /*  return now potentially pending token  */\n    if (this._pending.length > 0) {\n      const token = this._pending.shift();\n\n      if (token) {\n        if (this._transaction.length > 0) {\n          this._transaction[0].push(token);\n        }\n\n        this._log(`TOKEN: ${token.toString()}`);\n\n        return token;\n      }\n    }\n\n    /*  no more tokens  */\n    return null;\n  }\n\n  /**\n   * Determine and return all tokens as an Array\n   */\n  tokens(): Token[] {\n    const result: Token[] = [];\n\n    let token;\n\n    while ((token = this.token()) !== null) result.push(token);\n\n    return result;\n  }\n\n  /**\n   * Determine and generate tokens efficiently with a generator\n   */\n  *tokenGenerator(): Generator<Token> {\n    let token;\n\n    while ((token = this.token()) !== null) {\n      yield token;\n    }\n  }\n\n  /**\n   * Sugar method for setting the input and parsing for tokens in one method.\n   */\n  tokenize(contents: string): Token[] {\n    this.input(contents);\n\n    return this.tokens();\n  }\n\n  /**\n   * Peek at the next token or token at particular offset\n   */\n  peek(offset = 0): Token {\n    for (let i = 0; i < this._pending.length + offset; i++) {\n      this._tokenize();\n    }\n\n    if (offset >= this._pending.length) {\n      throw new Error(\"not enough tokens available for peek operation\");\n    }\n\n    this._log(`PEEK: ${this._pending[offset].toString()}`);\n\n    return this._pending[offset];\n  }\n\n  /**\n   * Skip one or more tokens\n   */\n  skip(len = 1): this {\n    for (let i = 0; i < this._pending.length + len; i++) {\n      this._tokenize();\n    }\n\n    if (len > this._pending.length) {\n      throw new Error(\"not enough tokens available for skip operation\");\n    }\n\n    // eslint-disable-next-line no-param-reassign\n    while (len-- > 0) {\n      this.token();\n    }\n\n    return this;\n  }\n\n  /**\n   * Consume the current token (by expecting it to be a particular symbol)\n   */\n  consume(type: string, value?: unknown): Token {\n    for (let i = 0; i < this._pending.length + 1; i++) {\n      this._tokenize();\n    }\n\n    if (this._pending.length === 0) {\n      throw new Error(\n        \"not enough tokens available for consume operation\"\n      );\n    }\n\n    const token = this.token() as Token;\n\n    this._log(`CONSUME: ${token.toString()}`);\n\n    const raiseError = (\n      expectedValue: unknown,\n      expectedType: string\n    ): void => {\n      throw new ParsingError(\n        `expected: <type: ${type}, value: ${JSON.stringify(\n          expectedValue\n        )} (${expectedType})>, ` +\n          `found: <type: ${token.type}, value: ${JSON.stringify(\n            token.value\n          )} (${typeof token.value})>`,\n        token.pos,\n        token.line,\n        token.column,\n        this._input\n      );\n    };\n\n    if (value && !token.isA(type, value)) {\n      raiseError(value, typeof value);\n    } else if (!token.isA(type)) {\n      raiseError(\"*\", \"any\");\n    }\n\n    return token;\n  }\n\n  /**\n   * Open tokenization transaction\n   */\n  begin(): this {\n    this._log(`BEGIN: level ${this._transaction.length}`);\n\n    this._transaction.unshift([]);\n\n    return this;\n  }\n\n  /**\n   * Determine depth of still open tokenization transaction\n   */\n  depth(): number {\n    if (this._transaction.length === 0) {\n      throw new Error(\n        \"cannot determine depth -- no active transaction\"\n      );\n    }\n\n    return this._transaction[0].length;\n  }\n\n  /**\n   * Close (successfully) tokenization transaction\n   */\n  commit(): this {\n    if (this._transaction.length === 0) {\n      throw new Error(\n        \"cannot commit transaction -- no active transaction\"\n      );\n    }\n\n    this._transaction.shift();\n\n    this._log(`COMMIT: level ${this._transaction.length}`);\n\n    return this;\n  }\n\n  /**\n   * Close (unsuccessfully) tokenization transaction\n   */\n  rollback(): this {\n    if (this._transaction.length === 0) {\n      throw new Error(\n        \"cannot rollback transaction -- no active transaction\"\n      );\n    }\n\n    this._pending = this._transaction[0].concat(this._pending);\n\n    this._transaction.shift();\n\n    this._log(`ROLLBACK: level ${this._transaction.length}`);\n\n    return this;\n  }\n\n  /**\n   * Execute multiple alternative callbacks\n   */\n  alternatives(\n    ...alternatives: ((tokenizr: this) => unknown)[]\n  ): unknown {\n    let result: unknown = null;\n    let depths: DepthError[] = [];\n\n    for (let i = 0; i < alternatives.length; i++) {\n      try {\n        this.begin();\n        result = alternatives[i].call(this, this);\n        this.commit();\n        break;\n      } catch (error) {\n        depths.push({\n          error,\n          depth: this.depth()\n        });\n        this.rollback();\n        this._log(`EXCEPTION: ${error.toString()}`);\n        continue;\n      }\n    }\n\n    if (result === null && depths.length > 0) {\n      depths = depths.sort((a, b) => a.depth - b.depth);\n\n      throw depths[0].error;\n    }\n\n    return result;\n  }\n\n  /**\n   * Output a debug message\n   */\n  _log(msg: string): void {\n    if (this.config.debug) {\n      /* eslint no-console: off */\n      console.log(`tokenizr: ${msg}`);\n    }\n  }\n\n  /**\n   * Determine the next token\n   */\n  private _tokenize(): void {\n    /*  helper function for finishing parsing  */\n    const finish = (): void => {\n      if (!this._eof) {\n        if (this._finish !== null) {\n          this._finish.call(this._ctx, this._ctx);\n        }\n\n        this._eof = true;\n\n        this._pending.push(\n          new Token(\"EOF\", \"\", \"\", this._pos, this._line, this._column)\n        );\n      }\n    };\n\n    /*  tokenize only as long as we were not stopped and there is input left  */\n    if (this._stopped || this._pos >= this._len) {\n      finish();\n      return;\n    }\n\n    /*  loop...  */\n    let continued = true;\n    while (continued) {\n      continued = false;\n\n      /*  some optional debugging context  */\n      if (this.config.debug) {\n        const e = excerpt(this._input, this._pos);\n        const tags = Object.keys(this._tag)\n          .map(tag => `#${tag}`)\n          .join(\" \");\n\n        this._log(\n          `INPUT: state: <${this._state.peek()}>, tags: <${tags}>, text: ` +\n            (e.prologTrunc ? \"...\" : '\"') +\n            `${e.prologText}<${e.tokenText}>${e.epilogText}` +\n            (e.epilogTrunc ? \"...\" : '\"') +\n            `, at: <line ${this._line}, column ${this._column}>`\n        );\n      }\n\n      /*  iterate over all rules...  */\n      for (let i = 0; i < this._rules.length; i++) {\n        const $rule = this._rules[i];\n\n        if (this.config.debug) {\n          let state = $rule.states[0];\n\n          if ($rule.states.length > 1) {\n            state = $rule.states.join(\", \");\n          }\n\n          this._log(\n            `  RULE: state(s): <${state}>, pattern: ${$rule._pattern.source}`\n          );\n        }\n\n        /*  one of rule's states (and all of its tags) has to match  */\n        let matches = false;\n        let statesMatch = false;\n\n        const currentState = this._state.peek();\n        // let idx = states.indexOf(\"*\");\n\n        /** didn't match the \"any\" state */\n        if ($rule.willMatchAnyState === false) {\n          statesMatch = $rule.hasState(currentState);\n        }\n\n        /** state matched, so check tags if any */\n        if (statesMatch) {\n          matches = true;\n\n          const matchedState = $rule.getState(currentState);\n\n          if (matchedState.isTagged) {\n            const tags = matchedState.filterTags(\n              tag => !this._tag[tag]\n            );\n\n            if (tags.length > 0) {\n              matches = false;\n            }\n          }\n        }\n\n        if (!matches) continue;\n\n        /*  match pattern at the last position  */\n        $rule._pattern.lastIndex = this._pos;\n        let found = $rule._pattern.exec(this._input);\n        $rule._pattern.lastIndex = this._pos;\n\n        if (\n          (found = $rule._pattern.exec(this._input)) !== null &&\n          found.index === this._pos\n        ) {\n          if (this.config.debug) {\n            this._log(\"    MATCHED: \" + JSON.stringify(found));\n          }\n\n          /*  pattern found, so give action a chance to operate\n              on it and act according to its results  */\n          this._ctx._match = found;\n          this._ctx._repeat = false;\n          this._ctx._reject = false;\n          this._ctx._ignore = false;\n\n          if (this._before !== null) {\n            this._before.call(this._ctx, this._ctx, found, $rule);\n          }\n\n          $rule._action.call(this._ctx, this._ctx, found, $rule);\n\n          if (this._after !== null) {\n            this._after.call(this._ctx, this._ctx, found, $rule);\n          }\n\n          /*  reject current action, continue matching  */\n          if (this._ctx._reject) {\n            continue;\n          }\n\n          /*  repeat matching from scratch  */\n          if (this._ctx._repeat) {\n            continued = true;\n            break;\n          }\n\n          /*  ignore token  */\n          if (this._ctx._ignore) {\n            this._progress(this._pos, $rule._pattern.lastIndex);\n            this._pos = $rule._pattern.lastIndex;\n\n            if (this._pos >= this._len) {\n              finish();\n              return;\n            }\n\n            continued = true;\n            break;\n          }\n\n          /*  accept token(s)  */\n          if (this._pending.length > 0) {\n            this._progress(this._pos, $rule._pattern.lastIndex);\n            this._pos = $rule._pattern.lastIndex;\n\n            if (this._pos >= this._len) {\n              finish();\n            }\n\n            return;\n          }\n\n          /*  nothing worked  */\n          throw new Error(\n            `action of pattern \"${$rule._pattern.source}\" neither rejected nor accepted any token(s)`\n          );\n        }\n      }\n    }\n\n    /*  no pattern matched at all  */\n    throw this.error(\"token not recognized\");\n  }\n\n  /**\n   * Progress the line/column counter\n   */\n  private _progress(from: number, until: number): void {\n    const line = this._line;\n    const column = this._column;\n    const s = this._input;\n\n    for (let i = from; i < until; i++) {\n      const c = s.charAt(i);\n\n      if (c === \"\\r\") {\n        this._column = 1;\n      } else if (c === \"\\n\") {\n        this._line++;\n        this._column = 1;\n      } else if (c === \"\\t\") {\n        this._column += 8 - (this._column % 8);\n      } else {\n        this._column++;\n      }\n    }\n\n    this._log(\n      `    PROGRESS: characters: ${until - from}, ` +\n        `from: <line ${line}, column ${column}>, ` +\n        `to: <line ${this._line}, column ${this._column}>`\n    );\n  }\n}\n"],"names":["Token","constructor","type","value","text","pos","line","column","this","toString","JSON","stringify","join","isA","ActionContext","tokenizr","_tokenizr","data","key","_data","info","_line","_column","_pos","len","_match","length","NaN","push","state","pop","tag","tagged","untag","repeat","_log","_repeat","reject","_reject","ignore","_ignore","accept","Error","_pending","stop","_stopped","hex","ch","charCodeAt","toUpperCase","extract","txt","substr","replace","excerpt","offset","textLength","start","end","prologTrunc","prologText","tokenText","epilogText","epilogTrunc","ParsingError","message","input","super","name","l","prefix1","prefix2","i","MatchResult","execArray","matched","index","Object","entries","forEach","result","map","find","filter","includes","assertIsString","error","AssertionError","expected","actual","Stack","[object Object]","element","stack","elements","isEmpty","isNotEmpty","clear","peek","undefined","StateStack","defaultState","State","stateDef","pieces","split","states","p","startsWith","tags","piece","taggedState","isTagged","stringifyTags","is","matches","a1","a2","item","reduce","a","c","filterTags","cb","hasTag","unTag","indexOf","Rule","_states","willMatchAnyState","hasState","hasPattern","_pattern","hasAction","_action","hasName","_name","test","exec","query","s","getState","getStates","setName","setAction","action","setState","stateDefs","create","addState","setPattern","pattern","flags","RegExp","sticky","ex","multiline","dotAll","ignoreCase","unicode","source","Tokenizr","config","defaults","_state","_ctx","reset","_input","_len","_eof","_transaction","debug","oldState","_tag","before","_before","after","_after","finish","_finish","rule","compile","_rules","ignoreRule","ctx","token","_tokenize","shift","tokens","tokenize","contents","skip","consume","raiseError","expectedValue","expectedType","begin","unshift","depth","commit","rollback","concat","alternatives","depths","call","sort","b","msg","console","log","continued","e","keys","$rule","statesMatch","currentState","matchedState","lastIndex","found","_progress","from","until","charAt"],"mappings":"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"}