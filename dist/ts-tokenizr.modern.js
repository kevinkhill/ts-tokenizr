import{AssertionError as t}from"assert";class e{constructor(t,e,s,i=0,n=0,r=0){this.type=t,this.value=e,this.text=s,this.pos=i,this.line=n,this.column=r}toString(){return`<${["type: "+this.type,"value: "+JSON.stringify(this.value),"text: "+JSON.stringify(this.text),"pos: "+this.pos,"line: "+this.line,"column: "+this.column].join(", ")}>`}isA(t,e){return t===this.type&&(!e||e===this.value)}}class s{constructor(t){this._repeat=!1,this._reject=!1,this._ignore=!1,this._data={},this._match=null,this._tokenizr=t}data(t,e){return void 0===e?this._data[t]:(this._data[t]=e,!0)}info(){return{line:this._tokenizr._line,column:this._tokenizr._column,pos:this._tokenizr._pos,len:this._match?this._match[0].length:NaN}}push(t){return this._tokenizr.push(t),this}pop(){return this._tokenizr.pop(),this}state(t){return void 0===t?this._tokenizr.state():(this._tokenizr.state(t),this)}tag(t){return this._tokenizr.tag(t),this}tagged(t){return this._tokenizr.tagged(t)}untag(t){return this._tokenizr.untag(t),this}repeat(){return this._tokenizr._log("    REPEAT"),this._repeat=!0,this}reject(){return this._tokenizr._log("    REJECT"),this._reject=!0,this}ignore(){return this._tokenizr._log("    IGNORE"),this._ignore=!0,this}accept(t,s){if(null===this._match)throw Error("this._match was null when trying to .accept()");return void 0===s&&(s=this._match[0]),this._tokenizr._log(`    ACCEPT: type: ${t}, value: ${JSON.stringify(s)} (${typeof s}), text: "${this._match[0]}"`),this._tokenizr._pending.push(new e(t,s,this._match[0],this._tokenizr._pos,this._tokenizr._line,this._tokenizr._column)),this}stop(){return this._tokenizr._stopped=!0,this}}function i(t){return t.charCodeAt(0).toString(16).toUpperCase()}function n(t,e,s){return t.substr(e,s).replace(/\\/g,"\\\\").replace(/\x08/g,"\\b").replace(/\t/g,"\\t").replace(/\n/g,"\\n").replace(/\f/g,"\\f").replace(/\r/g,"\\r").replace(/[\x00-\x07\x0B\x0E\x0F]/g,t=>"\\x0"+i(t)).replace(/[\x10-\x1F\x80-\xFF]/g,t=>"\\x"+i(t)).replace(/[\u0100-\u0FFF]/g,t=>"\\u0"+i(t)).replace(/[\u1000-\uFFFF]/g,t=>"\\u"+i(t))}function r(t,e){const s=t.length;let i=e-20;i<0&&(i=0);let r=e+20;return r>s&&(r=s),{prologTrunc:i>0,prologText:n(t,i,e-i),tokenText:n(t,e,1),epilogText:n(t,e+1,r-(e+1)),epilogTrunc:r<s}}class h extends Error{constructor(t,e,s,i,n){super(t),this.name="ParsingError",this.message=t,this.pos=e,this.line=s,this.column=i,this.input=n}toString(){const t=r(this.input,this.pos),e=`line ${this.line} (column ${this.column}): `;let s="";for(let i=0;i<e.length+t.prologText.length;i++)s+=" ";return"Parsing Error: "+this.message+"\n"+e+t.prologText+t.tokenText+t.epilogText+"\n"+s+"^"}}class o{constructor(t){this.matched=!1,this.result=[],(this.matched=null!==t)&&(this.input=t.input,this.index=t.index,Object.entries(t).forEach(([t,e])=>{"groups"!==t&&"input"!==t&&"index"!==t&&this.result.push(e)})),this.map=this.result.map,this.find=this.result.find,this.filter=this.result.filter,this.length=this.result.length,this.includes=this.result.includes}}function a(e,s){if("string"!=typeof e)throw new t({expected:"string",actual:typeof e,message:s||"The given input must be a string."})}class l{constructor(){this.elements=[]}static init(t){const e=new l;return e.push(t),e}get length(){return this.elements.length}get isEmpty(){return 0===this.length}get isNotEmpty(){return!this.isEmpty}clear(){this.elements=[]}push(t){return this.elements.push(t)}pop(){return this.elements.pop()}peek(){return this.isNotEmpty?this.elements[this.length-1]:void 0}}class u extends l{constructor(t){super(),this.defaultState=t,this.defaultState=t,this.elements.push(this.defaultState)}get isEmpty(){return 1===this.elements.length}clear(){this.elements=[this.defaultState]}pop(){if(this.isEmpty)throw Error(`ERROR: Cannot pop the default state "${this.defaultState}"`);return this.elements.pop()}peek(){return this.elements[this.elements.length-1]}}class _{constructor(t){this.name="default",this.tags=[];const e=t.split(/\s+/g),s=e.filter(t=>!t.startsWith("#"));if(1!==s.length)throw new Error("exactly one state required");this.name=s[0],this.tags=e.filter(t=>t.startsWith("#")).map(t=>t.replace("#",""))}static default(){return new _("default")}static create(t){return new _(t)}get isTagged(){return this.tags.length>0}toString(){return`${this.name} ${this.stringifyTags()}`}stringifyTags(){return this.tags.map(t=>"#"+t).join(" ")}is(t){return this.name===t}matches(t){return this.name===t.name&&((e=this.tags)===(s=t.tags)||e.length===s.length&&e.map(t=>s.includes(t)).reduce((t,e)=>t&&e,!0));var e,s}filterTags(t){return this.tags.filter(t)}hasTag(t){return this.tags.includes(t)}tag(t){return this.tags.push(t),this}unTag(t){return delete this.tags[this.tags.indexOf(t)],this}}class c{constructor(){this._name="unknown",this._states=[],this.stringify={}}get states(){return this._states.map(t=>t.toString())}get willMatchAnyState(){return this.hasState("*")}get hasPattern(){return void 0!==this._pattern}get hasAction(){return void 0!==this._action}get hasName(){return void 0!==this._name}test(t){return new o(this._pattern.exec(t))}state(t){return a(t),this._states.find(e=>e.name===t)}hasState(t){return this._states.filter(e=>e.is(t)).length>0}getState(t){if(!this.hasState(t))throw Error();return this._states.find(e=>e.is(t))}getStates(){return this._states.map(t=>t.name)}setName(t){return this._name=t,this}setAction(t){return this._action=t,this}setState(t){const e=t.split(/\s*,\s*/g);return this._states=e.map(_.create),this}addState(t){return this._states.push(new _(t)),this}setPattern(t){let e="g";try{"boolean"==typeof new RegExp("","y").sticky&&(e="y")}catch(t){}return"boolean"==typeof t.multiline&&t.multiline&&(e+="m"),"boolean"==typeof t.dotAll&&t.dotAll&&(e+="s"),"boolean"==typeof t.ignoreCase&&t.ignoreCase&&(e+="i"),"boolean"==typeof t.unicode&&t.unicode&&(e+="u"),this._pattern=new RegExp(t.source,e),this}}class g{constructor(t){this._len=0,this._pos=0,this._line=1,this._column=1,this._input="",this._eof=!1,this._stopped=!1,this._rules=[],this._pending=[],this._after=null,this._before=null,this._finish=null,this._tag={},this._transaction=[],this.config={...g.defaults,...t},this._state=new u("default"),this._ctx=new s(this)}reset(){return this._input="",this._len=0,this._eof=!1,this._pos=0,this._line=1,this._column=1,this._transaction=[],this._pending=[],this._stopped=!1,this._state.clear(),this._ctx=new s(this),this}error(t){return new h(t,this._pos,this._line,this._column,this._input)}debug(t){return this.config.debug=t,this}input(t){return a(t),this.reset(),this._input=t,this._len=t.length,this}push(t){const e=this._state.peek();return this._state.push(t),this._log(`    STATE (PUSH): old: <${e}>, new: <${t}>`),this}pop(){if(this._state.length<2)throw new Error("no more custom states to pop");const t=this._state.pop();return this._log(`    STATE (POP): old: <${t}>, new: <${this._state.peek()}>`),this}state(t){return void 0===t?this._state.peek():(this._log(`    STATE (SET): old: <${this._state.peek()}>, new: <${t}>`),this._state.push(t),this)}tag(t){return this._tag[t]=!0,this._log("    TAG (ADD): "+t),this}tagged(t){return!0===this._tag[t]}untag(t){return delete this._tag[t],this._log("    TAG (DEL): "+t),this}before(t){return this._before=t,this}after(t){return this._after=t,this}finish(t){return this._finish=t,this}rule(t,e,s="unknown",i="unknown"){const n=new c;return"string"==typeof t?n.setState(t):(n.setState("default"),n.setPattern(t)),void 0!==e.compile?n.setPattern(e):n.setAction(e),"string"==typeof s?n.setName(s):n.setAction(s),"string"==typeof i&&n.setName(i),this._rules.push(n),this.config.debug&&this._log(`rule: configure rule (state: ${n.states}, pattern: ${n._pattern.source})`),this}ignoreRule(t){return this.rule(t,t=>t.ignore())}token(){if(0===this._pending.length&&this._tokenize(),this._pending.length>0){const t=this._pending.shift();if(t)return this._transaction.length>0&&this._transaction[0].push(t),this._log("TOKEN: "+t.toString()),t}return null}tokens(){const t=[];let e;for(;null!==(e=this.token());)t.push(e);return t}*tokenGenerator(){let t;for(;null!==(t=this.token());)yield t}tokenize(t){return this.input(t),this.tokens()}peek(t=0){for(let e=0;e<this._pending.length+t;e++)this._tokenize();if(t>=this._pending.length)throw new Error("not enough tokens available for peek operation");return this._log("PEEK: "+this._pending[t].toString()),this._pending[t]}skip(t=1){for(let e=0;e<this._pending.length+t;e++)this._tokenize();if(t>this._pending.length)throw new Error("not enough tokens available for skip operation");for(;t-- >0;)this.token();return this}consume(t,e){for(let t=0;t<this._pending.length+1;t++)this._tokenize();if(0===this._pending.length)throw new Error("not enough tokens available for consume operation");const s=this.token();this._log("CONSUME: "+s.toString());const i=(e,i)=>{throw new h(`expected: <type: ${t}, value: ${JSON.stringify(e)} (${i})>, found: <type: ${s.type}, value: ${JSON.stringify(s.value)} (${typeof s.value})>`,s.pos,s.line,s.column,this._input)};return e&&!s.isA(t,e)?i(e,typeof e):s.isA(t)||i("*","any"),s}begin(){return this._log("BEGIN: level "+this._transaction.length),this._transaction.unshift([]),this}depth(){if(0===this._transaction.length)throw new Error("cannot determine depth -- no active transaction");return this._transaction[0].length}commit(){if(0===this._transaction.length)throw new Error("cannot commit transaction -- no active transaction");return this._transaction.shift(),this._log("COMMIT: level "+this._transaction.length),this}rollback(){if(0===this._transaction.length)throw new Error("cannot rollback transaction -- no active transaction");return this._pending=this._transaction[0].concat(this._pending),this._transaction.shift(),this._log("ROLLBACK: level "+this._transaction.length),this}alternatives(...t){let e=null,s=[];for(let i=0;i<t.length;i++)try{this.begin(),e=t[i].call(this,this),this.commit();break}catch(t){s.push({error:t,depth:this.depth()}),this.rollback(),this._log("EXCEPTION: "+t.toString());continue}if(null===e&&s.length>0)throw s=s.sort((t,e)=>t.depth-e.depth),s[0].error;return e}_log(t){this.config.debug&&console.log("tokenizr: "+t)}_tokenize(){const t=()=>{this._eof||(null!==this._finish&&this._finish.call(this._ctx,this._ctx),this._eof=!0,this._pending.push(new e("EOF","","",this._pos,this._line,this._column)))};if(this._stopped||this._pos>=this._len)return void t();let s=!0;for(;s;){if(s=!1,this.config.debug){const t=r(this._input,this._pos),e=Object.keys(this._tag).map(t=>"#"+t).join(" ");this._log(`INPUT: state: <${this._state.peek()}>, tags: <${e}>, text: `+(t.prologTrunc?"...":'"')+`${t.prologText}<${t.tokenText}>${t.epilogText}`+(t.epilogTrunc?"...":'"')+`, at: <line ${this._line}, column ${this._column}>`)}for(let e=0;e<this._rules.length;e++){const i=this._rules[e];if(this.config.debug){let t=i.states[0];i.states.length>1&&(t=i.states.join(", ")),this._log(`  RULE: state(s): <${t}>, pattern: ${i._pattern.source}`)}let n=!1,r=!1;const h=this._state.peek();if(!1===i.willMatchAnyState&&(r=i.hasState(h)),r){n=!0;const t=i.getState(h);t.isTagged&&t.filterTags(t=>!this._tag[t]).length>0&&(n=!1)}if(!n)continue;i._pattern.lastIndex=this._pos;let o=i._pattern.exec(this._input);if(i._pattern.lastIndex=this._pos,null!==(o=i._pattern.exec(this._input))&&o.index===this._pos){if(this.config.debug&&this._log("    MATCHED: "+JSON.stringify(o)),this._ctx._match=o,this._ctx._repeat=!1,this._ctx._reject=!1,this._ctx._ignore=!1,null!==this._before&&this._before.call(this._ctx,this._ctx,o,i),i._action.call(this._ctx,this._ctx,o,i),null!==this._after&&this._after.call(this._ctx,this._ctx,o,i),this._ctx._reject)continue;if(this._ctx._repeat){s=!0;break}if(this._ctx._ignore){if(this._progress(this._pos,i._pattern.lastIndex),this._pos=i._pattern.lastIndex,this._pos>=this._len)return void t();s=!0;break}if(this._pending.length>0)return this._progress(this._pos,i._pattern.lastIndex),this._pos=i._pattern.lastIndex,void(this._pos>=this._len&&t());throw new Error(`action of pattern "${i._pattern.source}" neither rejected nor accepted any token(s)`)}}}throw this.error("token not recognized")}_progress(t,e){const s=this._line,i=this._column,n=this._input;for(let s=t;s<e;s++){const t=n.charAt(s);"\r"===t?this._column=1:"\n"===t?(this._line++,this._column=1):"\t"===t?this._column+=8-this._column%8:this._column++}this._log(`    PROGRESS: characters: ${e-t}, from: <line ${s}, column ${i}>, to: <line ${this._line}, column ${this._column}>`)}}g.defaults={debug:!1};export{s as ActionContext,h as ParsingError,e as Token,g as Tokenizr};
//# sourceMappingURL=ts-tokenizr.modern.js.map
